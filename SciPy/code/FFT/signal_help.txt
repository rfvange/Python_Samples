Help on package scipy.signal in scipy:

NAME
    scipy.signal

FILE
    c:\python26\lib\site-packages\scipy\signal\__init__.py

DESCRIPTION
    Signal Processing Tools
    =======================
    
     Convolution:
    
        convolve:
            N-dimensional convolution.
    
        correlate:
            N-dimensional correlation.
        fftconvolve:
            N-dimensional convolution using the FFT.
        convolve2d:
            2-dimensional convolution (more options).
        correlate2d:
            2-dimensional correlation (more options).
        sepfir2d:
            Convolve with a 2-D separable FIR filter.
    
     B-splines:
    
        bspline:
            B-spline basis function of order n.
        gauss_spline:
            Gaussian approximation to the B-spline basis function.
        cspline1d:
            Coefficients for 1-D cubic (3rd order) B-spline.
        qspline1d:
            Coefficients for 1-D quadratic (2nd order) B-spline.
        cspline2d:
            Coefficients for 2-D cubic (3rd order) B-spline.
        qspline2d:
            Coefficients for 2-D quadratic (2nd order) B-spline.
        spline_filter:
            Smoothing spline (cubic) filtering of a rank-2 array.
    
     Filtering:
    
        order_filter:
            N-dimensional order filter.
        medfilt:
            N-dimensional median filter.
        medfilt2:
            2-dimensional median filter (faster).
        wiener:
            N-dimensional wiener filter.
        symiirorder1:
            2nd-order IIR filter (cascade of first-order systems).
        symiirorder2:
            4th-order IIR filter (cascade of second-order systems).
        lfilter:
            1-dimensional FIR and IIR digital linear filtering.
        lfiltic:
            Construct initial conditions for `lfilter`.
        deconvolve:
            1-d deconvolution using lfilter.
        hilbert:
            Compute the analytic signal of a 1-d signal.
        get_window:
            Create FIR window.
        decimate:
            Downsample a signal.
        detrend:
            Remove linear and/or constant trends from data.
        resample:
            Resample using Fourier method.
    
     Filter design:
    
        bilinear:
            Return a digital filter from an analog filter using the bilinear transform.
        firwin:
            Windowed FIR filter design.
        freqs:
            Analog filter frequency response.
        freqz:
            Digital filter frequency response.
        iirdesign:
            IIR filter design given bands and gains.
        iirfilter:
            IIR filter design given order and critical frequencies.
        invres:
            Inverse partial fraction expansion.
        kaiserord:
            Design a Kaiser window to limit ripple and width of transition region.
        remez:
            Optimal FIR filter design.
        residue:
            Partial fraction expansion of b(s) / a(s).
        residuez:
            Partial fraction expansion of b(z) / a(z).
        unique_roots:
            Unique roots and their multiplicities.
    
     Matlab-style IIR filter design:
    
        butter (buttord):
            Butterworth
        cheby1 (cheb1ord):
            Chebyshev Type I
        cheby2 (cheb2ord):
            Chebyshev Type II
        ellip (ellipord):
            Elliptic (Cauer)
        bessel:
            Bessel (no order selection available -- try butterod)
    
     Linear Systems:
    
        lti:
            linear time invariant system object.
        lsim:
            continuous-time simulation of output to linear system.
        lsim2:
            like lsim, but `scipy.integrate.odeint` is used.
        impulse:
            impulse response of linear, time-invariant (LTI) system.
        impulse2:
            like impulse, but `scipy.integrate.odeint` is used.
        step:
            step response of continous-time LTI system.
        step2:
            like step, but `scipy.integrate.odeint` is used.
    
     LTI Representations:
    
        tf2zpk:
            transfer function to zero-pole-gain.
        zpk2tf:
            zero-pole-gain to transfer function.
        tf2ss:
            transfer function to state-space.
        ss2tf:
            state-pace to transfer function.
        zpk2ss:
            zero-pole-gain to state-space.
        ss2zpk:
            state-space to pole-zero-gain.
    
     Waveforms:
    
        sawtooth:
            Periodic sawtooth
        square:
            Square wave
        gausspulse:
            Gaussian modulated sinusoid
        chirp:
            Frequency swept cosine signal, with several frequency functions.
        sweep_poly:
            Frequency swept cosine signal; frequency is arbitrary polynomial.
    
     Window functions:
    
        get_window:
            Return a window of a given length and type.
        barthann:
            Bartlett-Hann window
        bartlett:
            Bartlett window
        blackman:
            Blackman window
        blackmanharris:
            Minimum 4-term Blackman-Harris window
        bohman:
            Bohman window
        boxcar:
            Boxcar window
        chebwin:
            Dolph-Chebyshev window
        flattop:
            Flat top window
        gaussian:
            Gaussian window
        general_gaussian:
            Generalized Gaussian window
        hamming:
            Hamming window
        hann:
            Hann window
        kaiser:
            Kaiser window
        nuttall:
            Nuttall's minimum 4-term Blackman-Harris window
        parzen:
            Parzen window
        slepian:
            Slepian window
        triang:
            Triangular window
    
     Wavelets:
    
        daub:
            return low-pass
        qmf:
            return quadrature mirror filter from low-pass
        cascade:
            compute scaling function and wavelet from coefficients
        morlet:
            Complex Morlet wavelet.

PACKAGE CONTENTS
    bsplines
    filter_design
    info
    ltisys
    setup
    setupscons
    signaltools
    sigtools
    spline
    waveforms
    wavelets
    windows

CLASSES
    __builtin__.object
        numpy.ndarray
        scipy.signal.ltisys.lti
    exceptions.UserWarning(exceptions.Warning)
        scipy.signal.filter_design.BadCoefficients
    
    class BadCoefficients(exceptions.UserWarning)
     |  Method resolution order:
     |      BadCoefficients
     |      exceptions.UserWarning
     |      exceptions.Warning
     |      exceptions.Exception
     |      exceptions.BaseException
     |      __builtin__.object
     |  
     |  Data descriptors defined here:
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.UserWarning:
     |  
     |  __init__(...)
     |      x.__init__(...) initializes x; see x.__class__.__doc__ for signature
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from exceptions.UserWarning:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x1E1D8248>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from exceptions.BaseException:
     |  
     |  __delattr__(...)
     |      x.__delattr__('name') <==> del x.name
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __reduce__(...)
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __setattr__(...)
     |      x.__setattr__('name', value) <==> x.name = value
     |  
     |  __setstate__(...)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __unicode__(...)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from exceptions.BaseException:
     |  
     |  __dict__
     |  
     |  args
     |  
     |  message
    
    class lti(__builtin__.object)
     |  Linear Time Invariant class which simplifies representation.
     |  
     |  Methods defined here:
     |  
     |  __init__(self, *args, **kwords)
     |      Initialize the LTI system using either:
     |      (numerator, denominator)
     |      (zeros, poles, gain)
     |      (A, B, C, D) -- state-space.
     |  
     |  __setattr__(self, attr, val)
     |  
     |  impulse(self, X0=None, T=None, N=None)
     |  
     |  output(self, U, T, X0=None)
     |  
     |  step(self, X0=None, T=None, N=None)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ndarray(__builtin__.object)
     |  ndarray(shape, dtype=float, buffer=None, offset=0,
     |          strides=None, order=None)
     |  
     |  An array object represents a multidimensional, homogeneous array
     |  of fixed-size items.  An associated data-type object describes the
     |  format of each element in the array (its byte-order, how many bytes it
     |  occupies in memory, whether it is an integer, a floating point number,
     |  or something else, etc.)
     |  
     |  Arrays should be constructed using `array`, `zeros` or `empty` (refer
     |  to the See Also section below).  The parameters given here refer to
     |  a low-level method (`ndarray(...)`) for instantiating an array.
     |  
     |  For more information, refer to the `numpy` module and examine the
     |  the methods and attributes of an array.
     |  
     |  Parameters
     |  ----------
     |  (for the __new__ method; see Notes below)
     |  
     |  shape : tuple of ints
     |      Shape of created array.
     |  dtype : data-type, optional
     |      Any object that can be interpreted as a numpy data type.
     |  buffer : object exposing buffer interface, optional
     |      Used to fill the array with data.
     |  offset : int, optional
     |      Offset of array data in buffer.
     |  strides : tuple of ints, optional
     |      Strides of data in memory.
     |  order : {'C', 'F'}, optional
     |      Row-major or column-major order.
     |  
     |  Attributes
     |  ----------
     |  T : ndarray
     |      Transpose of the array.
     |  data : buffer
     |      The array's elements, in memory.
     |  dtype : dtype object
     |      Describes the format of the elements in the array.
     |  flags : dict
     |      Dictionary containing information related to memory use, e.g.,
     |      'C_CONTIGUOUS', 'OWNDATA', 'WRITEABLE', etc.
     |  flat : numpy.flatiter object
     |      Flattened version of the array as an iterator.  The iterator
     |      allows assignments, e.g., ``x.flat = 3`` (See `ndarray.flat` for
     |      assignment examples; TODO).
     |  imag : ndarray
     |      Imaginary part of the array.
     |  real : ndarray
     |      Real part of the array.
     |  size : int
     |      Number of elements in the array.
     |  itemsize : int
     |      The memory use of each array element in bytes.
     |  nbytes : int
     |      The total number of bytes required to store the array data,
     |      i.e., ``itemsize * size``.
     |  ndim : int
     |      The array's number of dimensions.
     |  shape : tuple of ints
     |      Shape of the array.
     |  strides : tuple of ints
     |      The step-size required to move from one element to the next in
     |      memory. For example, a contiguous ``(3, 4)`` array of type
     |      ``int16`` in C-order has strides ``(8, 2)``.  This implies that
     |      to move from element to element in memory requires jumps of 2 bytes.
     |      To move from row-to-row, one needs to jump 8 bytes at a time
     |      (``2 * 4``).
     |  ctypes : ctypes object
     |      Class containing properties of the array needed for interaction
     |      with ctypes.
     |  base : ndarray
     |      If the array is a view into another array, that array is its `base`
     |      (unless that array is also a view).  The `base` array is where the
     |      array data is actually stored.
     |  
     |  See Also
     |  --------
     |  array : Construct an array.
     |  zeros : Create an array, each element of which is zero.
     |  empty : Create an array, but leave its allocated memory unchanged (i.e.,
     |          it contains "garbage").
     |  dtype : Create a data-type.
     |  
     |  Notes
     |  -----
     |  There are two modes of creating an array using ``__new__``:
     |  
     |  1. If `buffer` is None, then only `shape`, `dtype`, and `order`
     |     are used.
     |  2. If `buffer` is an object exposing the buffer interface, then
     |     all keywords are interpreted.
     |  
     |  No ``__init__`` method is needed because the array is fully initialized
     |  after the ``__new__`` method.
     |  
     |  Examples
     |  --------
     |  These examples illustrate the low-level `ndarray` constructor.  Refer
     |  to the `See Also` section above for easier ways of constructing an
     |  ndarray.
     |  
     |  First mode, `buffer` is None:
     |  
     |  >>> np.ndarray(shape=(2,2), dtype=float, order='F')
     |  array([[ -1.13698227e+002,   4.25087011e-303],
     |         [  2.88528414e-306,   3.27025015e-309]])         #random
     |  
     |  Second mode:
     |  
     |  >>> np.ndarray((2,), buffer=np.array([1,2,3]),
     |  ...            offset=np.int_().itemsize,
     |  ...            dtype=int) # offset = 1*itemsize, i.e. skip first element
     |  array([2, 3])
     |  
     |  Methods defined here:
     |  
     |  __abs__(...)
     |      x.__abs__() <==> abs(x)
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __and__(...)
     |      x.__and__(y) <==> x&y
     |  
     |  __array__(...)
     |      a.__array__(|dtype) -> reference if type unchanged, copy otherwise.
     |      
     |      Returns either a new reference to self if dtype is not given or a new array
     |      of provided data type if dtype is different from the current dtype of the
     |      array.
     |  
     |  __array_prepare__(...)
     |      a.__array_prepare__(obj) -> Object of same type as ndarray object obj.
     |  
     |  __array_wrap__(...)
     |      a.__array_wrap__(obj) -> Object of same type as ndarray object a.
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  __copy__(...)
     |      a.__copy__([order])
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A'}, optional
     |          If order is 'C' (False) then the result is contiguous (default).
     |          If order is 'Fortran' (True) then the result has fortran order.
     |          If order is 'Any' (None) then the result has fortran order
     |          only if the array already is in fortran order.
     |  
     |  __deepcopy__(...)
     |      a.__deepcopy__() -> Deep copy of array.
     |      
     |      Used if copy.deepcopy is called on an array.
     |  
     |  __delitem__(...)
     |      x.__delitem__(y) <==> del x[y]
     |  
     |  __delslice__(...)
     |      x.__delslice__(i, j) <==> del x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __div__(...)
     |      x.__div__(y) <==> x/y
     |  
     |  __divmod__(...)
     |      x.__divmod__(y) <==> divmod(x, y)
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __float__(...)
     |      x.__float__() <==> float(x)
     |  
     |  __floordiv__(...)
     |      x.__floordiv__(y) <==> x//y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __hex__(...)
     |      x.__hex__() <==> hex(x)
     |  
     |  __iadd__(...)
     |      x.__iadd__(y) <==> x+y
     |  
     |  __iand__(...)
     |      x.__iand__(y) <==> x&y
     |  
     |  __idiv__(...)
     |      x.__idiv__(y) <==> x/y
     |  
     |  __ifloordiv__(...)
     |      x.__ifloordiv__(y) <==> x//y
     |  
     |  __ilshift__(...)
     |      x.__ilshift__(y) <==> x<<y
     |  
     |  __imod__(...)
     |      x.__imod__(y) <==> x%y
     |  
     |  __imul__(...)
     |      x.__imul__(y) <==> x*y
     |  
     |  __index__(...)
     |      x[y:z] <==> x[y.__index__():z.__index__()]
     |  
     |  __int__(...)
     |      x.__int__() <==> int(x)
     |  
     |  __invert__(...)
     |      x.__invert__() <==> ~x
     |  
     |  __ior__(...)
     |      x.__ior__(y) <==> x|y
     |  
     |  __ipow__(...)
     |      x.__ipow__(y) <==> x**y
     |  
     |  __irshift__(...)
     |      x.__irshift__(y) <==> x>>y
     |  
     |  __isub__(...)
     |      x.__isub__(y) <==> x-y
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __itruediv__(...)
     |      x.__itruediv__(y) <==> x/y
     |  
     |  __ixor__(...)
     |      x.__ixor__(y) <==> x^y
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __long__(...)
     |      x.__long__() <==> long(x)
     |  
     |  __lshift__(...)
     |      x.__lshift__(y) <==> x<<y
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mod__(...)
     |      x.__mod__(y) <==> x%y
     |  
     |  __mul__(...)
     |      x.__mul__(y) <==> x*y
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __neg__(...)
     |      x.__neg__() <==> -x
     |  
     |  __nonzero__(...)
     |      x.__nonzero__() <==> x != 0
     |  
     |  __oct__(...)
     |      x.__oct__() <==> oct(x)
     |  
     |  __or__(...)
     |      x.__or__(y) <==> x|y
     |  
     |  __pos__(...)
     |      x.__pos__() <==> +x
     |  
     |  __pow__(...)
     |      x.__pow__(y[, z]) <==> pow(x, y[, z])
     |  
     |  __radd__(...)
     |      x.__radd__(y) <==> y+x
     |  
     |  __rand__(...)
     |      x.__rand__(y) <==> y&x
     |  
     |  __rdiv__(...)
     |      x.__rdiv__(y) <==> y/x
     |  
     |  __rdivmod__(...)
     |      x.__rdivmod__(y) <==> divmod(y, x)
     |  
     |  __reduce__(...)
     |      a.__reduce__()
     |      
     |      For pickling.
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __rfloordiv__(...)
     |      x.__rfloordiv__(y) <==> y//x
     |  
     |  __rlshift__(...)
     |      x.__rlshift__(y) <==> y<<x
     |  
     |  __rmod__(...)
     |      x.__rmod__(y) <==> y%x
     |  
     |  __rmul__(...)
     |      x.__rmul__(y) <==> y*x
     |  
     |  __ror__(...)
     |      x.__ror__(y) <==> y|x
     |  
     |  __rpow__(...)
     |      y.__rpow__(x[, z]) <==> pow(x, y[, z])
     |  
     |  __rrshift__(...)
     |      x.__rrshift__(y) <==> y>>x
     |  
     |  __rshift__(...)
     |      x.__rshift__(y) <==> x>>y
     |  
     |  __rsub__(...)
     |      x.__rsub__(y) <==> y-x
     |  
     |  __rtruediv__(...)
     |      x.__rtruediv__(y) <==> y/x
     |  
     |  __rxor__(...)
     |      x.__rxor__(y) <==> y^x
     |  
     |  __setitem__(...)
     |      x.__setitem__(i, y) <==> x[i]=y
     |  
     |  __setslice__(...)
     |      x.__setslice__(i, j, y) <==> x[i:j]=y
     |      
     |      Use  of negative indices is not supported.
     |  
     |  __setstate__(...)
     |      a.__setstate__(version, shape, dtype, isfortran, rawdata)
     |      
     |      For unpickling.
     |      
     |      Parameters
     |      ----------
     |      version : int
     |          optional pickle version. If omitted defaults to 0.
     |      shape : tuple
     |      dtype : data-type
     |      isFortran : bool
     |      rawdata : string or list
     |          a binary string with the data (or a list if 'a' is an object array)
     |  
     |  __str__(...)
     |      x.__str__() <==> str(x)
     |  
     |  __sub__(...)
     |      x.__sub__(y) <==> x-y
     |  
     |  __truediv__(...)
     |      x.__truediv__(y) <==> x/y
     |  
     |  __xor__(...)
     |      x.__xor__(y) <==> x^y
     |  
     |  all(...)
     |      a.all(axis=None, out=None)
     |      
     |      Returns True if all elements evaluate to True.
     |      
     |      Refer to `numpy.all` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.all : equivalent function
     |  
     |  any(...)
     |      a.any(axis=None, out=None)
     |      
     |      Returns True if any of the elements of `a` evaluate to True.
     |      
     |      Refer to `numpy.any` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.any : equivalent function
     |  
     |  argmax(...)
     |      a.argmax(axis=None, out=None)
     |      
     |      Return indices of the maximum values along the given axis.
     |      
     |      Refer to `numpy.argmax` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.argmax : equivalent function
     |  
     |  argmin(...)
     |      a.argmin(axis=None, out=None)
     |      
     |      Return indices of the minimum values along the given axis of `a`.
     |      
     |      Refer to `numpy.argmin` for detailed documentation.
     |      
     |      See Also
     |      --------
     |      numpy.argmin : equivalent function
     |  
     |  argsort(...)
     |      a.argsort(axis=-1, kind='quicksort', order=None)
     |      
     |      Returns the indices that would sort this array.
     |      
     |      Refer to `numpy.argsort` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.argsort : equivalent function
     |  
     |  astype(...)
     |      a.astype(t)
     |      
     |      Copy of the array, cast to a specified type.
     |      
     |      Parameters
     |      ----------
     |      t : string or dtype
     |          Typecode or data-type to which the array is cast.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 2.5])
     |      >>> x
     |      array([ 1. ,  2. ,  2.5])
     |      
     |      >>> x.astype(int)
     |      array([1, 2, 2])
     |  
     |  byteswap(...)
     |      a.byteswap(inplace)
     |      
     |      Swap the bytes of the array elements
     |      
     |      Toggle between low-endian and big-endian data representation by
     |      returning a byteswapped array, optionally swapped in-place.
     |      
     |      Parameters
     |      ----------
     |      inplace: bool, optional
     |          If ``True``, swap bytes in-place, default is ``False``.
     |      
     |      Returns
     |      -------
     |      out: ndarray
     |          The byteswapped array. If `inplace` is ``True``, this is
     |          a view to self.
     |      
     |      Examples
     |      --------
     |      >>> A = np.array([1, 256, 8755], dtype=np.int16)
     |      >>> map(hex, A)
     |      ['0x1', '0x100', '0x2233']
     |      >>> A.byteswap(True)
     |      array([  256,     1, 13090], dtype=int16)
     |      >>> map(hex, A)
     |      ['0x100', '0x1', '0x3322']
     |      
     |      Arrays of strings are not swapped
     |      
     |      >>> A = np.array(['ceg', 'fac'])
     |      >>> A.byteswap()
     |      array(['ceg', 'fac'],
     |            dtype='|S3')
     |  
     |  choose(...)
     |      a.choose(choices, out=None, mode='raise')
     |      
     |      Use an index array to construct a new array from a set of choices.
     |      
     |      Refer to `numpy.choose` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.choose : equivalent function
     |  
     |  clip(...)
     |      a.clip(a_min, a_max, out=None)
     |      
     |      Return an array whose values are limited to ``[a_min, a_max]``.
     |      
     |      Refer to `numpy.clip` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.clip : equivalent function
     |  
     |  compress(...)
     |      a.compress(condition, axis=None, out=None)
     |      
     |      Return selected slices of this array along given axis.
     |      
     |      Refer to `numpy.compress` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.compress : equivalent function
     |  
     |  conj(...)
     |      a.conj()
     |      
     |      Complex-conjugate all elements.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  conjugate(...)
     |      a.conjugate()
     |      
     |      Return the complex conjugate, element-wise.
     |      
     |      Refer to `numpy.conjugate` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.conjugate : equivalent function
     |  
     |  copy(...)
     |      a.copy(order='C')
     |      
     |      Return a copy of the array.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', 'A'}, optional
     |          By default, the result is stored in C-contiguous (row-major) order in
     |          memory.  If `order` is `F`, the result has 'Fortran' (column-major)
     |          order.  If order is 'A' ('Any'), then the result has the same order
     |          as the input.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([[1,2,3],[4,5,6]], order='F')
     |      
     |      >>> y = x.copy()
     |      
     |      >>> x.fill(0)
     |      
     |      >>> x
     |      array([[0, 0, 0],
     |             [0, 0, 0]])
     |      
     |      >>> y
     |      array([[1, 2, 3],
     |             [4, 5, 6]])
     |      
     |      >>> y.flags['C_CONTIGUOUS']
     |      True
     |  
     |  cumprod(...)
     |      a.cumprod(axis=None, dtype=None, out=None)
     |      
     |      Return the cumulative product of the elements along the given axis.
     |      
     |      Refer to `numpy.cumprod` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.cumprod : equivalent function
     |  
     |  cumsum(...)
     |      a.cumsum(axis=None, dtype=None, out=None)
     |      
     |      Return the cumulative sum of the elements along the given axis.
     |      
     |      Refer to `numpy.cumsum` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.cumsum : equivalent function
     |  
     |  diagonal(...)
     |      a.diagonal(offset=0, axis1=0, axis2=1)
     |      
     |      Return specified diagonals.
     |      
     |      Refer to `numpy.diagonal` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.diagonal : equivalent function
     |  
     |  dot(...)
     |  
     |  dump(...)
     |      a.dump(file)
     |      
     |      Dump a pickle of the array to the specified file.
     |      The array can be read back with pickle.load or numpy.load.
     |      
     |      Parameters
     |      ----------
     |      file : str
     |          A string naming the dump file.
     |  
     |  dumps(...)
     |      a.dumps()
     |      
     |      Returns the pickle of the array as a string.
     |      pickle.loads or numpy.loads will convert the string back to an array.
     |      
     |      Parameters
     |      ----------
     |      None
     |  
     |  fill(...)
     |      a.fill(value)
     |      
     |      Fill the array with a scalar value.
     |      
     |      Parameters
     |      ----------
     |      value : scalar
     |          All elements of `a` will be assigned this value.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([1, 2])
     |      >>> a.fill(0)
     |      >>> a
     |      array([0, 0])
     |      >>> a = np.empty(2)
     |      >>> a.fill(1)
     |      >>> a
     |      array([ 1.,  1.])
     |  
     |  flatten(...)
     |      a.flatten(order='C')
     |      
     |      Return a copy of the array collapsed into one dimension.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F'}, optional
     |          Whether to flatten in C (row-major) or Fortran (column-major) order.
     |          The default is 'C'.
     |      
     |      Returns
     |      -------
     |      y : ndarray
     |          A copy of the input array, flattened to one dimension.
     |      
     |      See Also
     |      --------
     |      ravel : Return a flattened array.
     |      flat : A 1-D flat iterator over the array.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1,2], [3,4]])
     |      >>> a.flatten()
     |      array([1, 2, 3, 4])
     |      >>> a.flatten('F')
     |      array([1, 3, 2, 4])
     |  
     |  getfield(...)
     |      a.getfield(dtype, offset)
     |      
     |      Returns a field of the given array as a certain type.
     |      
     |      A field is a view of the array data with each itemsize determined
     |      by the given type and the offset into the current array, i.e. from
     |      ``offset * dtype.itemsize`` to ``(offset+1) * dtype.itemsize``.
     |      
     |      Parameters
     |      ----------
     |      dtype : str
     |          String denoting the data type of the field.
     |      offset : int
     |          Number of `dtype.itemsize`'s to skip before beginning the element view.
     |      
     |      Examples
     |      --------
     |      >>> x = np.diag([1.+1.j]*2)
     |      >>> x
     |      array([[ 1.+1.j,  0.+0.j],
     |             [ 0.+0.j,  1.+1.j]])
     |      >>> x.dtype
     |      dtype('complex128')
     |      
     |      >>> x.getfield('complex64', 0) # Note how this != x
     |      array([[ 0.+1.875j,  0.+0.j   ],
     |             [ 0.+0.j   ,  0.+1.875j]], dtype=complex64)
     |      
     |      >>> x.getfield('complex64',1) # Note how different this is than x
     |      array([[ 0. +5.87173204e-39j,  0. +0.00000000e+00j],
     |             [ 0. +0.00000000e+00j,  0. +5.87173204e-39j]], dtype=complex64)
     |      
     |      >>> x.getfield('complex128', 0) # == x
     |      array([[ 1.+1.j,  0.+0.j],
     |             [ 0.+0.j,  1.+1.j]])
     |      
     |      If the argument dtype is the same as x.dtype, then offset != 0 raises
     |      a ValueError:
     |      
     |      >>> x.getfield('complex128', 1)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: Need 0 <= offset <= 0 for requested type but received offset = 1
     |      
     |      >>> x.getfield('float64', 0)
     |      array([[ 1.,  0.],
     |             [ 0.,  1.]])
     |      
     |      >>> x.getfield('float64', 1)
     |      array([[  1.77658241e-307,   0.00000000e+000],
     |             [  0.00000000e+000,   1.77658241e-307]])
     |  
     |  item(...)
     |      a.item(*args)
     |      
     |      Copy an element of an array to a standard Python scalar and return it.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments (variable number and type)
     |      
     |          * none: in this case, the method only works for arrays
     |            with one element (`a.size == 1`), which element is
     |            copied into a standard Python scalar object and returned.
     |      
     |          * int_type: this argument is interpreted as a flat index into
     |            the array, specifying which element to copy and return.
     |      
     |          * tuple of int_types: functions as does a single int_type argument,
     |            except that the argument is interpreted as an nd-index into the
     |            array.
     |      
     |      Returns
     |      -------
     |      z : Standard Python scalar object
     |          A copy of the specified element of the array as a suitable
     |          Python scalar
     |      
     |      Notes
     |      -----
     |      When the data type of `a` is longdouble or clongdouble, item() returns
     |      a scalar array object because there is no available Python scalar that
     |      would not lose information. Void arrays return a buffer object for item(),
     |      unless fields are defined, in which case a tuple is returned.
     |      
     |      `item` is very similar to a[args], except, instead of an array scalar,
     |      a standard Python scalar is returned. This can be useful for speeding up
     |      access to elements of the array and doing arithmetic on elements of the
     |      array using Python's optimized math.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.item(3)
     |      2
     |      >>> x.item(7)
     |      5
     |      >>> x.item((0, 1))
     |      1
     |      >>> x.item((2, 2))
     |      3
     |  
     |  itemset(...)
     |      a.itemset(*args)
     |      
     |      Insert scalar into an array (scalar is cast to array's dtype, if possible)
     |      
     |      There must be at least 1 argument, and define the last argument
     |      as *item*.  Then, ``a.itemset(*args)`` is equivalent to but faster
     |      than ``a[args] = item``.  The item should be a scalar value and `args`
     |      must select a single item in the array `a`.
     |      
     |      Parameters
     |      ----------
     |      \*args : Arguments
     |          If one argument: a scalar, only used in case `a` is of size 1.
     |          If two arguments: the last argument is the value to be set
     |          and must be a scalar, the first argument specifies a single array
     |          element location. It is either an int or a tuple.
     |      
     |      Notes
     |      -----
     |      Compared to indexing syntax, `itemset` provides some speed increase
     |      for placing a scalar into a particular location in an `ndarray`,
     |      if you must do this.  However, generally this is discouraged:
     |      among other problems, it complicates the appearance of the code.
     |      Also, when using `itemset` (and `item`) inside a loop, be sure
     |      to assign the methods to a local variable to avoid the attribute
     |      look-up at each loop iteration.
     |      
     |      Examples
     |      --------
     |      >>> x = np.random.randint(9, size=(3, 3))
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 8, 3],
     |             [8, 5, 3]])
     |      >>> x.itemset(4, 0)
     |      >>> x.itemset((2, 2), 9)
     |      >>> x
     |      array([[3, 1, 7],
     |             [2, 0, 3],
     |             [8, 5, 9]])
     |  
     |  max(...)
     |      a.max(axis=None, out=None)
     |      
     |      Return the maximum along a given axis.
     |      
     |      Refer to `numpy.amax` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.amax : equivalent function
     |  
     |  mean(...)
     |      a.mean(axis=None, dtype=None, out=None)
     |      
     |      Returns the average of the array elements along given axis.
     |      
     |      Refer to `numpy.mean` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.mean : equivalent function
     |  
     |  min(...)
     |      a.min(axis=None, out=None)
     |      
     |      Return the minimum along a given axis.
     |      
     |      Refer to `numpy.amin` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.amin : equivalent function
     |  
     |  newbyteorder(...)
     |      arr.newbyteorder(new_order='S')
     |      
     |      Return the array with the same data viewed with a different byte order.
     |      
     |      Equivalent to::
     |      
     |          arr.view(arr.dtype.newbytorder(new_order))
     |      
     |      Changes are also made in all fields and sub-arrays of the array data
     |      type.
     |      
     |      
     |      
     |      Parameters
     |      ----------
     |      new_order : string, optional
     |          Byte order to force; a value from the byte order specifications
     |          above. `new_order` codes can be any of::
     |      
     |           * 'S' - swap dtype from current to opposite endian
     |           * {'<', 'L'} - little endian
     |           * {'>', 'B'} - big endian
     |           * {'=', 'N'} - native order
     |           * {'|', 'I'} - ignore (no change to byte order)
     |      
     |          The default value ('S') results in swapping the current
     |          byte order. The code does a case-insensitive check on the first
     |          letter of `new_order` for the alternatives above.  For example,
     |          any of 'B' or 'b' or 'biggish' are valid to specify big-endian.
     |      
     |      
     |      Returns
     |      -------
     |      new_arr : array
     |          New array object with the dtype reflecting given change to the
     |          byte order.
     |  
     |  nonzero(...)
     |      a.nonzero()
     |      
     |      Return the indices of the elements that are non-zero.
     |      
     |      Refer to `numpy.nonzero` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.nonzero : equivalent function
     |  
     |  prod(...)
     |      a.prod(axis=None, dtype=None, out=None)
     |      
     |      Return the product of the array elements over the given axis
     |      
     |      Refer to `numpy.prod` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.prod : equivalent function
     |  
     |  ptp(...)
     |      a.ptp(axis=None, out=None)
     |      
     |      Peak to peak (maximum - minimum) value along a given axis.
     |      
     |      Refer to `numpy.ptp` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.ptp : equivalent function
     |  
     |  put(...)
     |      a.put(indices, values, mode='raise')
     |      
     |      Set ``a.flat[n] = values[n]`` for all `n` in indices.
     |      
     |      Refer to `numpy.put` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.put : equivalent function
     |  
     |  ravel(...)
     |      a.ravel([order])
     |      
     |      Return a flattened array.
     |      
     |      Refer to `numpy.ravel` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.ravel : equivalent function
     |      
     |      ndarray.flat : a flat iterator on the array.
     |  
     |  repeat(...)
     |      a.repeat(repeats, axis=None)
     |      
     |      Repeat elements of an array.
     |      
     |      Refer to `numpy.repeat` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.repeat : equivalent function
     |  
     |  reshape(...)
     |      a.reshape(shape, order='C')
     |      
     |      Returns an array containing the same data with a new shape.
     |      
     |      Refer to `numpy.reshape` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.reshape : equivalent function
     |  
     |  resize(...)
     |      a.resize(new_shape, refcheck=True)
     |      
     |      Change shape and size of array in-place.
     |      
     |      Parameters
     |      ----------
     |      new_shape : tuple of ints, or `n` ints
     |          Shape of resized array.
     |      refcheck : bool, optional
     |          If False, reference count will not be checked. Default is True.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      Raises
     |      ------
     |      ValueError
     |          If `a` does not own its own data or references or views to it exist,
     |          and the data memory must be changed.
     |      
     |      SystemError
     |          If the `order` keyword argument is specified. This behaviour is a
     |          bug in NumPy.
     |      
     |      See Also
     |      --------
     |      resize : Return a new array with the specified shape.
     |      
     |      Notes
     |      -----
     |      This reallocates space for the data area if necessary.
     |      
     |      Only contiguous arrays (data elements consecutive in memory) can be
     |      resized.
     |      
     |      The purpose of the reference count check is to make sure you
     |      do not use this array as a buffer for another Python object and then
     |      reallocate the memory. However, reference counts can increase in
     |      other ways so if you are sure that you have not shared the memory
     |      for this array with another Python object, then you may safely set
     |      `refcheck` to False.
     |      
     |      Examples
     |      --------
     |      Shrinking an array: array is flattened (in the order that the data are
     |      stored in memory), resized, and reshaped:
     |      
     |      >>> a = np.array([[0, 1], [2, 3]], order='C')
     |      >>> a.resize((2, 1))
     |      >>> a
     |      array([[0],
     |             [1]])
     |      
     |      >>> a = np.array([[0, 1], [2, 3]], order='F')
     |      >>> a.resize((2, 1))
     |      >>> a
     |      array([[0],
     |             [2]])
     |      
     |      Enlarging an array: as above, but missing entries are filled with zeros:
     |      
     |      >>> b = np.array([[0, 1], [2, 3]])
     |      >>> b.resize(2, 3) # new_shape parameter doesn't have to be a tuple
     |      >>> b
     |      array([[0, 1, 2],
     |             [3, 0, 0]])
     |      
     |      Referencing an array prevents resizing...
     |      
     |      >>> c = a
     |      >>> a.resize((1, 1))
     |      Traceback (most recent call last):
     |      ...
     |      ValueError: cannot resize an array that has been referenced ...
     |      
     |      Unless `refcheck` is False:
     |      
     |      >>> a.resize((1, 1), refcheck=False)
     |      >>> a
     |      array([[0]])
     |      >>> c
     |      array([[0]])
     |  
     |  round(...)
     |      a.round(decimals=0, out=None)
     |      
     |      Return `a` with each element rounded to the given number of decimals.
     |      
     |      Refer to `numpy.around` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.around : equivalent function
     |  
     |  searchsorted(...)
     |      a.searchsorted(v, side='left')
     |      
     |      Find indices where elements of v should be inserted in a to maintain order.
     |      
     |      For full documentation, see `numpy.searchsorted`
     |      
     |      See Also
     |      --------
     |      numpy.searchsorted : equivalent function
     |  
     |  setfield(...)
     |      a.setfield(val, dtype, offset=0)
     |      
     |      Put a value into a specified place in a field defined by a data-type.
     |      
     |      Place `val` into `a`'s field defined by `dtype` and beginning `offset`
     |      bytes into the field.
     |      
     |      Parameters
     |      ----------
     |      val : object
     |          Value to be placed in field.
     |      dtype : dtype object
     |          Data-type of the field in which to place `val`.
     |      offset : int, optional
     |          The number of bytes into the field at which to place `val`.
     |      
     |      Returns
     |      -------
     |      None
     |      
     |      See Also
     |      --------
     |      getfield
     |      
     |      Examples
     |      --------
     |      >>> x = np.eye(3)
     |      >>> x.getfield(np.float64)
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |      >>> x.setfield(3, np.int32)
     |      >>> x.getfield(np.int32)
     |      array([[3, 3, 3],
     |             [3, 3, 3],
     |             [3, 3, 3]])
     |      >>> x
     |      array([[  1.00000000e+000,   1.48219694e-323,   1.48219694e-323],
     |             [  1.48219694e-323,   1.00000000e+000,   1.48219694e-323],
     |             [  1.48219694e-323,   1.48219694e-323,   1.00000000e+000]])
     |      >>> x.setfield(np.eye(3), np.int32)
     |      >>> x
     |      array([[ 1.,  0.,  0.],
     |             [ 0.,  1.,  0.],
     |             [ 0.,  0.,  1.]])
     |  
     |  setflags(...)
     |      a.setflags(write=None, align=None, uic=None)
     |      
     |      Set array flags WRITEABLE, ALIGNED, and UPDATEIFCOPY, respectively.
     |      
     |      These Boolean-valued flags affect how numpy interprets the memory
     |      area used by `a` (see Notes below). The ALIGNED flag can only
     |      be set to True if the data is actually aligned according to the type.
     |      The UPDATEIFCOPY flag can never be set to True. The flag WRITEABLE
     |      can only be set to True if the array owns its own memory, or the
     |      ultimate owner of the memory exposes a writeable buffer interface,
     |      or is a string. (The exception for string is made so that unpickling
     |      can be done without copying memory.)
     |      
     |      Parameters
     |      ----------
     |      write : bool, optional
     |          Describes whether or not `a` can be written to.
     |      align : bool, optional
     |          Describes whether or not `a` is aligned properly for its type.
     |      uic : bool, optional
     |          Describes whether or not `a` is a copy of another "base" array.
     |      
     |      Notes
     |      -----
     |      Array flags provide information about how the memory area used
     |      for the array is to be interpreted. There are 6 Boolean flags
     |      in use, only three of which can be changed by the user:
     |      UPDATEIFCOPY, WRITEABLE, and ALIGNED.
     |      
     |      WRITEABLE (W) the data area can be written to;
     |      
     |      ALIGNED (A) the data and strides are aligned appropriately for the hardware
     |      (as determined by the compiler);
     |      
     |      UPDATEIFCOPY (U) this array is a copy of some other array (referenced
     |      by .base). When this array is deallocated, the base array will be
     |      updated with the contents of this array.
     |      
     |      All flags can be accessed using their first (upper case) letter as well
     |      as the full name.
     |      
     |      Examples
     |      --------
     |      >>> y
     |      array([[3, 1, 7],
     |             [2, 0, 0],
     |             [8, 5, 9]])
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : True
     |        ALIGNED : True
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(write=0, align=0)
     |      >>> y.flags
     |        C_CONTIGUOUS : True
     |        F_CONTIGUOUS : False
     |        OWNDATA : True
     |        WRITEABLE : False
     |        ALIGNED : False
     |        UPDATEIFCOPY : False
     |      >>> y.setflags(uic=1)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: cannot set UPDATEIFCOPY flag to True
     |  
     |  sort(...)
     |      a.sort(axis=-1, kind='quicksort', order=None)
     |      
     |      Sort an array, in-place.
     |      
     |      Parameters
     |      ----------
     |      axis : int, optional
     |          Axis along which to sort. Default is -1, which means sort along the
     |          last axis.
     |      kind : {'quicksort', 'mergesort', 'heapsort'}, optional
     |          Sorting algorithm. Default is 'quicksort'.
     |      order : list, optional
     |          When `a` is an array with fields defined, this argument specifies
     |          which fields to compare first, second, etc.  Not all fields need be
     |          specified.
     |      
     |      See Also
     |      --------
     |      numpy.sort : Return a sorted copy of an array.
     |      argsort : Indirect sort.
     |      lexsort : Indirect stable sort on multiple keys.
     |      searchsorted : Find elements in sorted array.
     |      
     |      Notes
     |      -----
     |      See ``sort`` for notes on the different sorting algorithms.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1,4], [3,1]])
     |      >>> a.sort(axis=1)
     |      >>> a
     |      array([[1, 4],
     |             [1, 3]])
     |      >>> a.sort(axis=0)
     |      >>> a
     |      array([[1, 3],
     |             [1, 4]])
     |      
     |      Use the `order` keyword to specify a field to use when sorting a
     |      structured array:
     |      
     |      >>> a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])
     |      >>> a.sort(order='y')
     |      >>> a
     |      array([('c', 1), ('a', 2)],
     |            dtype=[('x', '|S1'), ('y', '<i4')])
     |  
     |  squeeze(...)
     |      a.squeeze()
     |      
     |      Remove single-dimensional entries from the shape of `a`.
     |      
     |      Refer to `numpy.squeeze` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.squeeze : equivalent function
     |  
     |  std(...)
     |      a.std(axis=None, dtype=None, out=None, ddof=0)
     |      
     |      Returns the standard deviation of the array elements along given axis.
     |      
     |      Refer to `numpy.std` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.std : equivalent function
     |  
     |  sum(...)
     |      a.sum(axis=None, dtype=None, out=None)
     |      
     |      Return the sum of the array elements over the given axis.
     |      
     |      Refer to `numpy.sum` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.sum : equivalent function
     |  
     |  swapaxes(...)
     |      a.swapaxes(axis1, axis2)
     |      
     |      Return a view of the array with `axis1` and `axis2` interchanged.
     |      
     |      Refer to `numpy.swapaxes` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.swapaxes : equivalent function
     |  
     |  take(...)
     |      a.take(indices, axis=None, out=None, mode='raise')
     |      
     |      Return an array formed from the elements of `a` at the given indices.
     |      
     |      Refer to `numpy.take` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.take : equivalent function
     |  
     |  tofile(...)
     |      a.tofile(fid, sep="", format="%s")
     |      
     |      Write array to a file as text or binary (default).
     |      
     |      Data is always written in 'C' order, independent of the order of `a`.
     |      The data produced by this method can be recovered using the function
     |      fromfile().
     |      
     |      Parameters
     |      ----------
     |      fid : file or str
     |          An open file object, or a string containing a filename.
     |      sep : str
     |          Separator between array items for text output.
     |          If "" (empty), a binary file is written, equivalent to
     |          ``file.write(a.tostring())``.
     |      format : str
     |          Format string for text file output.
     |          Each entry in the array is formatted to text by first converting
     |          it to the closest Python type, and then using "format" % item.
     |      
     |      Notes
     |      -----
     |      This is a convenience function for quick storage of array data.
     |      Information on endianness and precision is lost, so this method is not a
     |      good choice for files intended to archive data or transport data between
     |      machines with different endianness. Some of these problems can be overcome
     |      by outputting the data as text files, at the expense of speed and file
     |      size.
     |  
     |  tolist(...)
     |      a.tolist()
     |      
     |      Return the array as a (possibly nested) list.
     |      
     |      Return a copy of the array data as a (nested) Python list.
     |      Data items are converted to the nearest compatible Python type.
     |      
     |      Parameters
     |      ----------
     |      none
     |      
     |      Returns
     |      -------
     |      y : list
     |          The possibly nested list of array elements.
     |      
     |      Notes
     |      -----
     |      The array may be recreated, ``a = np.array(a.tolist())``.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([1, 2])
     |      >>> a.tolist()
     |      [1, 2]
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> list(a)
     |      [array([1, 2]), array([3, 4])]
     |      >>> a.tolist()
     |      [[1, 2], [3, 4]]
     |  
     |  tostring(...)
     |      a.tostring(order='C')
     |      
     |      Construct a Python string containing the raw data bytes in the array.
     |      
     |      Constructs a Python string showing a copy of the raw contents of
     |      data memory. The string can be produced in either 'C' or 'Fortran',
     |      or 'Any' order (the default is 'C'-order). 'Any' order means C-order
     |      unless the F_CONTIGUOUS flag in the array is set, in which case it
     |      means 'Fortran' order.
     |      
     |      Parameters
     |      ----------
     |      order : {'C', 'F', None}, optional
     |          Order of the data for multidimensional arrays:
     |          C, Fortran, or the same as for the original array.
     |      
     |      Returns
     |      -------
     |      s : str
     |          A Python string exhibiting a copy of `a`'s raw data.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([[0, 1], [2, 3]])
     |      >>> x.tostring()
     |      '\x00\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'
     |      >>> x.tostring('C') == x.tostring()
     |      True
     |      >>> x.tostring('F')
     |      '\x00\x00\x00\x00\x02\x00\x00\x00\x01\x00\x00\x00\x03\x00\x00\x00'
     |  
     |  trace(...)
     |      a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)
     |      
     |      Return the sum along diagonals of the array.
     |      
     |      Refer to `numpy.trace` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.trace : equivalent function
     |  
     |  transpose(...)
     |      a.transpose(*axes)
     |      
     |      Returns a view of the array with axes transposed.
     |      
     |      For a 1-D array, this has no effect. (To change between column and
     |      row vectors, first cast the 1-D array into a matrix object.)
     |      For a 2-D array, this is the usual matrix transpose.
     |      For an n-D array, if axes are given, their order indicates how the
     |      axes are permuted (see Examples). If axes are not provided and
     |      ``a.shape = (i[0], i[1], ... i[n-2], i[n-1])``, then
     |      ``a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])``.
     |      
     |      Parameters
     |      ----------
     |      axes : None, tuple of ints, or `n` ints
     |      
     |       * None or no argument: reverses the order of the axes.
     |      
     |       * tuple of ints: `i` in the `j`-th place in the tuple means `a`'s
     |         `i`-th axis becomes `a.transpose()`'s `j`-th axis.
     |      
     |       * `n` ints: same as an n-tuple of the same ints (this form is
     |         intended simply as a "convenience" alternative to the tuple form)
     |      
     |      Returns
     |      -------
     |      out : ndarray
     |          View of `a`, with axes suitably permuted.
     |      
     |      See Also
     |      --------
     |      ndarray.T : Array property returning the array transposed.
     |      
     |      Examples
     |      --------
     |      >>> a = np.array([[1, 2], [3, 4]])
     |      >>> a
     |      array([[1, 2],
     |             [3, 4]])
     |      >>> a.transpose()
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose((1, 0))
     |      array([[1, 3],
     |             [2, 4]])
     |      >>> a.transpose(1, 0)
     |      array([[1, 3],
     |             [2, 4]])
     |  
     |  var(...)
     |      a.var(axis=None, dtype=None, out=None, ddof=0)
     |      
     |      Returns the variance of the array elements, along given axis.
     |      
     |      Refer to `numpy.var` for full documentation.
     |      
     |      See Also
     |      --------
     |      numpy.var : equivalent function
     |  
     |  view(...)
     |      a.view(dtype=None, type=None)
     |      
     |      New view of array with the same data.
     |      
     |      Parameters
     |      ----------
     |      dtype : data-type, optional
     |          Data-type descriptor of the returned view, e.g., float32 or int16.
     |          The default, None, results in the view having the same data-type
     |          as `a`.
     |      type : Python type, optional
     |          Type of the returned view, e.g., ndarray or matrix.  Again, the
     |          default None results in type preservation.
     |      
     |      Notes
     |      -----
     |      ``a.view()`` is used two different ways:
     |      
     |      ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
     |      of the array's memory with a different data-type.  This can cause a
     |      reinterpretation of the bytes of memory.
     |      
     |      ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
     |      returns an instance of `ndarray_subclass` that looks at the same array
     |      (same shape, dtype, etc.)  This does not cause a reinterpretation of the
     |      memory.
     |      
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])
     |      
     |      Viewing array data using a different type and dtype:
     |      
     |      >>> y = x.view(dtype=np.int16, type=np.matrix)
     |      >>> y
     |      matrix([[513]], dtype=int16)
     |      >>> print type(y)
     |      <class 'numpy.matrixlib.defmatrix.matrix'>
     |      
     |      Creating a view on a structured array so it can be used in calculations
     |      
     |      >>> x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])
     |      >>> xv = x.view(dtype=np.int8).reshape(-1,2)
     |      >>> xv
     |      array([[1, 2],
     |             [3, 4]], dtype=int8)
     |      >>> xv.mean(0)
     |      array([ 2.,  3.])
     |      
     |      Making changes to the view changes the underlying array
     |      
     |      >>> xv[0,1] = 20
     |      >>> print x
     |      [(1, 20) (3, 4)]
     |      
     |      Using a view to convert an array to a record array:
     |      
     |      >>> z = x.view(np.recarray)
     |      >>> z.a
     |      array([1], dtype=int8)
     |      
     |      Views share data:
     |      
     |      >>> x[0] = (9, 10)
     |      >>> z[0]
     |      (9, 10)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  T
     |      Same as self.transpose(), except that self is returned if
     |      self.ndim < 2.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([[1.,2.],[3.,4.]])
     |      >>> x
     |      array([[ 1.,  2.],
     |             [ 3.,  4.]])
     |      >>> x.T
     |      array([[ 1.,  3.],
     |             [ 2.,  4.]])
     |      >>> x = np.array([1.,2.,3.,4.])
     |      >>> x
     |      array([ 1.,  2.,  3.,  4.])
     |      >>> x.T
     |      array([ 1.,  2.,  3.,  4.])
     |  
     |  __array_finalize__
     |      None.
     |  
     |  __array_interface__
     |      Array protocol: Python side.
     |  
     |  __array_priority__
     |      Array priority.
     |  
     |  __array_struct__
     |      Array protocol: C-struct side.
     |  
     |  base
     |      Base object if memory is from some other object.
     |      
     |      Examples
     |      --------
     |      The base of an array that owns its memory is None:
     |      
     |      >>> x = np.array([1,2,3,4])
     |      >>> x.base is None
     |      True
     |      
     |      Slicing creates a view, whose memory is shared with x:
     |      
     |      >>> y = x[2:]
     |      >>> y.base is x
     |      True
     |  
     |  ctypes
     |      An object to simplify the interaction of the array with the ctypes
     |      module.
     |      
     |      This attribute creates an object that makes it easier to use arrays
     |      when calling shared libraries with the ctypes module. The returned
     |      object has, among others, data, shape, and strides attributes (see
     |      Notes below) which themselves return ctypes objects that can be used
     |      as arguments to a shared library.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      c : Python object
     |          Possessing attributes data, shape, strides, etc.
     |      
     |      See Also
     |      --------
     |      numpy.ctypeslib
     |      
     |      Notes
     |      -----
     |      Below are the public attributes of this object which were documented
     |      in "Guide to NumPy" (we have omitted undocumented public attributes,
     |      as well as documented private attributes):
     |      
     |      * data: A pointer to the memory area of the array as a Python integer.
     |        This memory area may contain data that is not aligned, or not in correct
     |        byte-order. The memory area may not even be writeable. The array
     |        flags and data-type of this array should be respected when passing this
     |        attribute to arbitrary C-code to avoid trouble that can include Python
     |        crashing. User Beware! The value of this attribute is exactly the same
     |        as self._array_interface_['data'][0].
     |      
     |      * shape (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the C-integer corresponding to dtype('p') on this
     |        platform. This base-type could be c_int, c_long, or c_longlong
     |        depending on the platform. The c_intp type is defined accordingly in
     |        numpy.ctypeslib. The ctypes array contains the shape of the underlying
     |        array.
     |      
     |      * strides (c_intp*self.ndim): A ctypes array of length self.ndim where
     |        the basetype is the same as for the shape attribute. This ctypes array
     |        contains the strides information from the underlying array. This strides
     |        information is important for showing how many bytes must be jumped to
     |        get to the next element in the array.
     |      
     |      * data_as(obj): Return the data pointer cast to a particular c-types object.
     |        For example, calling self._as_parameter_ is equivalent to
     |        self.data_as(ctypes.c_void_p). Perhaps you want to use the data as a
     |        pointer to a ctypes array of floating-point data:
     |        self.data_as(ctypes.POINTER(ctypes.c_double)).
     |      
     |      * shape_as(obj): Return the shape tuple as an array of some other c-types
     |        type. For example: self.shape_as(ctypes.c_short).
     |      
     |      * strides_as(obj): Return the strides tuple as an array of some other
     |        c-types type. For example: self.strides_as(ctypes.c_longlong).
     |      
     |      Be careful using the ctypes attribute - especially on temporary
     |      arrays or arrays constructed on the fly. For example, calling
     |      ``(a+b).ctypes.data_as(ctypes.c_void_p)`` returns a pointer to memory
     |      that is invalid because the array created as (a+b) is deallocated
     |      before the next Python statement. You can avoid this problem using
     |      either ``c=a+b`` or ``ct=(a+b).ctypes``. In the latter case, ct will
     |      hold a reference to the array until ct is deleted or re-assigned.
     |      
     |      If the ctypes module is not available, then the ctypes attribute
     |      of array objects still returns something useful, but ctypes objects
     |      are not returned and errors may be raised instead. In particular,
     |      the object will still have the as parameter attribute which will
     |      return an integer equal to the data attribute.
     |      
     |      Examples
     |      --------
     |      >>> import ctypes
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.ctypes.data
     |      30439712
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))
     |      <ctypes.LP_c_long object at 0x01F01300>
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents
     |      c_long(0)
     |      >>> x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents
     |      c_longlong(4294967296L)
     |      >>> x.ctypes.shape
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FFD580>
     |      >>> x.ctypes.shape_as(ctypes.c_long)
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides
     |      <numpy.core._internal.c_long_Array_2 object at 0x01FCE620>
     |      >>> x.ctypes.strides_as(ctypes.c_longlong)
     |      <numpy.core._internal.c_longlong_Array_2 object at 0x01F01300>
     |  
     |  data
     |      Python buffer object pointing to the start of the array's data.
     |  
     |  dtype
     |      Data-type of the array's elements.
     |      
     |      Parameters
     |      ----------
     |      None
     |      
     |      Returns
     |      -------
     |      d : numpy dtype object
     |      
     |      See Also
     |      --------
     |      numpy.dtype
     |      
     |      Examples
     |      --------
     |      >>> x
     |      array([[0, 1],
     |             [2, 3]])
     |      >>> x.dtype
     |      dtype('int32')
     |      >>> type(x.dtype)
     |      <type 'numpy.dtype'>
     |  
     |  flags
     |      Information about the memory layout of the array.
     |      
     |      Attributes
     |      ----------
     |      C_CONTIGUOUS (C)
     |          The data is in a single, C-style contiguous segment.
     |      F_CONTIGUOUS (F)
     |          The data is in a single, Fortran-style contiguous segment.
     |      OWNDATA (O)
     |          The array owns the memory it uses or borrows it from another object.
     |      WRITEABLE (W)
     |          The data area can be written to.  Setting this to False locks
     |          the data, making it read-only.  A view (slice, etc.) inherits WRITEABLE
     |          from its base array at creation time, but a view of a writeable
     |          array may be subsequently locked while the base array remains writeable.
     |          (The opposite is not true, in that a view of a locked array may not
     |          be made writeable.  However, currently, locking a base object does not
     |          lock any views that already reference it, so under that circumstance it
     |          is possible to alter the contents of a locked array via a previously
     |          created writeable view onto it.)  Attempting to change a non-writeable
     |          array raises a RuntimeError exception.
     |      ALIGNED (A)
     |          The data and strides are aligned appropriately for the hardware.
     |      UPDATEIFCOPY (U)
     |          This array is a copy of some other array. When this array is
     |          deallocated, the base array will be updated with the contents of
     |          this array.
     |      
     |      FNC
     |          F_CONTIGUOUS and not C_CONTIGUOUS.
     |      FORC
     |          F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).
     |      BEHAVED (B)
     |          ALIGNED and WRITEABLE.
     |      CARRAY (CA)
     |          BEHAVED and C_CONTIGUOUS.
     |      FARRAY (FA)
     |          BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.
     |      
     |      Notes
     |      -----
     |      The `flags` object can be accessed dictionary-like (as in ``a.flags['WRITEABLE']``),
     |      or by using lowercased attribute names (as in ``a.flags.writeable``). Short flag
     |      names are only supported in dictionary access.
     |      
     |      Only the UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by
     |      the user, via direct assignment to the attribute or dictionary entry,
     |      or by calling `ndarray.setflags`.
     |      
     |      The array flags cannot be set arbitrarily:
     |      
     |      - UPDATEIFCOPY can only be set ``False``.
     |      - ALIGNED can only be set ``True`` if the data is truly aligned.
     |      - WRITEABLE can only be set ``True`` if the array owns its own memory
     |        or the ultimate owner of the memory exposes a writeable buffer
     |        interface or is a string.
     |  
     |  flat
     |      A 1-D iterator over the array.
     |      
     |      This is a `numpy.flatiter` instance, which acts similarly to, but is not
     |      a subclass of, Python's built-in iterator object.
     |      
     |      See Also
     |      --------
     |      flatten : Return a copy of the array collapsed into one dimension.
     |      
     |      flatiter
     |      
     |      Examples
     |      --------
     |      >>> x = np.arange(1, 7).reshape(2, 3)
     |      >>> x
     |      array([[1, 2, 3],
     |             [4, 5, 6]])
     |      >>> x.flat[3]
     |      4
     |      >>> x.T
     |      array([[1, 4],
     |             [2, 5],
     |             [3, 6]])
     |      >>> x.T.flat[3]
     |      5
     |      >>> type(x.flat)
     |      <type 'numpy.flatiter'>
     |      
     |      An assignment example:
     |      
     |      >>> x.flat = 3; x
     |      array([[3, 3, 3],
     |             [3, 3, 3]])
     |      >>> x.flat[[1,4]] = 1; x
     |      array([[3, 1, 3],
     |             [3, 1, 3]])
     |  
     |  imag
     |      The imaginary part of the array.
     |      
     |      Examples
     |      --------
     |      >>> x = np.sqrt([1+0j, 0+1j])
     |      >>> x.imag
     |      array([ 0.        ,  0.70710678])
     |      >>> x.imag.dtype
     |      dtype('float64')
     |  
     |  itemsize
     |      Length of one array element in bytes.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1,2,3], dtype=np.float64)
     |      >>> x.itemsize
     |      8
     |      >>> x = np.array([1,2,3], dtype=np.complex128)
     |      >>> x.itemsize
     |      16
     |  
     |  nbytes
     |      Total bytes consumed by the elements of the array.
     |      
     |      Notes
     |      -----
     |      Does not include memory consumed by non-element attributes of the
     |      array object.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3,5,2), dtype=np.complex128)
     |      >>> x.nbytes
     |      480
     |      >>> np.prod(x.shape) * x.itemsize
     |      480
     |  
     |  ndim
     |      Number of array dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3])
     |      >>> x.ndim
     |      1
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.ndim
     |      3
     |  
     |  real
     |      The real part of the array.
     |      
     |      Examples
     |      --------
     |      >>> x = np.sqrt([1+0j, 0+1j])
     |      >>> x.real
     |      array([ 1.        ,  0.70710678])
     |      >>> x.real.dtype
     |      dtype('float64')
     |      
     |      See Also
     |      --------
     |      numpy.real : equivalent function
     |  
     |  shape
     |      Tuple of array dimensions.
     |      
     |      Notes
     |      -----
     |      May be used to "reshape" the array, as long as this would not
     |      require a change in the total number of elements
     |      
     |      Examples
     |      --------
     |      >>> x = np.array([1, 2, 3, 4])
     |      >>> x.shape
     |      (4,)
     |      >>> y = np.zeros((2, 3, 4))
     |      >>> y.shape
     |      (2, 3, 4)
     |      >>> y.shape = (3, 8)
     |      >>> y
     |      array([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],
     |             [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])
     |      >>> y.shape = (3, 6)
     |      Traceback (most recent call last):
     |        File "<stdin>", line 1, in <module>
     |      ValueError: total size of new array must be unchanged
     |  
     |  size
     |      Number of elements in the array.
     |      
     |      Equivalent to ``np.prod(a.shape)``, i.e., the product of the array's
     |      dimensions.
     |      
     |      Examples
     |      --------
     |      >>> x = np.zeros((3, 5, 2), dtype=np.complex128)
     |      >>> x.size
     |      30
     |      >>> np.prod(x.shape)
     |      30
     |  
     |  strides
     |      Tuple of bytes to step in each dimension when traversing an array.
     |      
     |      The byte offset of element ``(i[0], i[1], ..., i[n])`` in an array `a`
     |      is::
     |      
     |          offset = sum(np.array(i) * a.strides)
     |      
     |      A more detailed explanation of strides can be found in the
     |      "ndarray.rst" file in the NumPy reference guide.
     |      
     |      Notes
     |      -----
     |      Imagine an array of 32-bit integers (each 4 bytes)::
     |      
     |        x = np.array([[0, 1, 2, 3, 4],
     |                      [5, 6, 7, 8, 9]], dtype=np.int32)
     |      
     |      This array is stored in memory as 40 bytes, one after the other
     |      (known as a contiguous block of memory).  The strides of an array tell
     |      us how many bytes we have to skip in memory to move to the next position
     |      along a certain axis.  For example, we have to skip 4 bytes (1 value) to
     |      move to the next column, but 20 bytes (5 values) to get to the same
     |      position in the next row.  As such, the strides for the array `x` will be
     |      ``(20, 4)``.
     |      
     |      See Also
     |      --------
     |      numpy.lib.stride_tricks.as_strided
     |      
     |      Examples
     |      --------
     |      >>> y = np.reshape(np.arange(2*3*4), (2,3,4))
     |      >>> y
     |      array([[[ 0,  1,  2,  3],
     |              [ 4,  5,  6,  7],
     |              [ 8,  9, 10, 11]],
     |             [[12, 13, 14, 15],
     |              [16, 17, 18, 19],
     |              [20, 21, 22, 23]]])
     |      >>> y.strides
     |      (48, 16, 4)
     |      >>> y[1,1,1]
     |      17
     |      >>> offset=sum(y.strides * np.array((1,1,1)))
     |      >>> offset/y.itemsize
     |      17
     |      
     |      >>> x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)
     |      >>> x.strides
     |      (32, 4, 224, 1344)
     |      >>> i = np.array([3,5,2,2])
     |      >>> offset = sum(i * x.strides)
     |      >>> x[3,5,2,2]
     |      813
     |      >>> offset / x.itemsize
     |      813
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  __new__ = <built-in method __new__ of type object at 0x69BDC7C0>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T

FUNCTIONS
    abcd_normalize(A=None, B=None, C=None, D=None)
        Check state-space matrices and ensure they are rank-2.
    
    allclose(a, b, rtol=1.0000000000000001e-05, atol=1e-08)
        Returns True if two arrays are element-wise equal within a tolerance.
        
        The tolerance values are positive, typically very small numbers.  The
        relative difference (`rtol` * abs(`b`)) and the absolute difference
        `atol` are added together to compare against the absolute difference
        between `a` and `b`.
        
        Parameters
        ----------
        a, b : array_like
            Input arrays to compare.
        rtol : float
            The relative tolerance parameter (see Notes).
        atol : float
            The absolute tolerance parameter (see Notes).
        
        Returns
        -------
        y : bool
            Returns True if the two arrays are equal within the given
            tolerance; False otherwise. If either array contains NaN, then
            False is returned.
        
        See Also
        --------
        all, any, alltrue, sometrue
        
        Notes
        -----
        If the following equation is element-wise True, then allclose returns
        True.
        
         absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
        
        The above equation is not symmetric in `a` and `b`, so that
        `allclose(a, b)` might be different from `allclose(b, a)` in
        some rare cases.
        
        Examples
        --------
        >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
        False
        >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
        True
        >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
        False
        >>> np.allclose([1.0, np.nan], [1.0, np.nan])
        False
    
    any(a, axis=None, out=None)
        Test whether any array element along a given axis evaluates to True.
        
        Returns single boolean unless `axis` is not ``None``
        
        Parameters
        ----------
        a : array_like
            Input array or object that can be converted to an array.
        axis : int, optional
            Axis along which a logical OR is performed.  The default
            (`axis` = `None`) is to perform a logical OR over a flattened
            input array. `axis` may be negative, in which case it counts
            from the last to the first axis.
        out : ndarray, optional
            Alternate output array in which to place the result.  It must have
            the same shape as the expected output and its type is preserved
            (e.g., if it is of type float, then it will remain so, returning
            1.0 for True and 0.0 for False, regardless of the type of `a`).
            See `doc.ufuncs` (Section "Output arguments") for details.
        
        Returns
        -------
        any : bool or ndarray
            A new boolean or `ndarray` is returned unless `out` is specified,
            in which case a reference to `out` is returned.
        
        See Also
        --------
        ndarray.any : equivalent method
        
        all : Test whether all elements along a given axis evaluate to True.
        
        Notes
        -----
        Not a Number (NaN), positive infinity and negative infinity evaluate
        to `True` because these are not equal to zero.
        
        Examples
        --------
        >>> np.any([[True, False], [True, True]])
        True
        
        >>> np.any([[True, False], [False, False]], axis=0)
        array([ True, False], dtype=bool)
        
        >>> np.any([-1, 0, 5])
        True
        
        >>> np.any(np.nan)
        True
        
        >>> o=np.array([False])
        >>> z=np.any([-1, 4, 5], out=o)
        >>> z, o
        (array([ True], dtype=bool), array([ True], dtype=bool))
        >>> # Check now that z is a reference to o
        >>> z is o
        True
        >>> id(z), id(o) # identity of z and o              # doctest: +SKIP
        (191614240, 191614240)
    
    arange(...)
        arange([start,] stop[, step,], dtype=None)
        
        Return evenly spaced values within a given interval.
        
        Values are generated within the half-open interval ``[start, stop)``
        (in other words, the interval including `start` but excluding `stop`).
        For integer arguments the function is equivalent to the Python built-in
        `range <http://docs.python.org/lib/built-in-funcs.html>`_ function,
        but returns a ndarray rather than a list.
        
        Parameters
        ----------
        start : number, optional
            Start of interval.  The interval includes this value.  The default
            start value is 0.
        stop : number
            End of interval.  The interval does not include this value.
        step : number, optional
            Spacing between values.  For any output `out`, this is the distance
            between two adjacent values, ``out[i+1] - out[i]``.  The default
            step size is 1.  If `step` is specified, `start` must also be given.
        dtype : dtype
            The type of the output array.  If `dtype` is not given, infer the data
            type from the other input arguments.
        
        Returns
        -------
        out : ndarray
            Array of evenly spaced values.
        
            For floating point arguments, the length of the result is
            ``ceil((stop - start)/step)``.  Because of floating point overflow,
            this rule may result in the last element of `out` being greater
            than `stop`.
        
        See Also
        --------
        linspace : Evenly spaced numbers with careful handling of endpoints.
        ogrid: Arrays of evenly spaced numbers in N-dimensions
        mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions
        
        Examples
        --------
        >>> np.arange(3)
        array([0, 1, 2])
        >>> np.arange(3.0)
        array([ 0.,  1.,  2.])
        >>> np.arange(3,7)
        array([3, 4, 5, 6])
        >>> np.arange(3,7,2)
        array([3, 5])
    
    argsort(a, axis=-1, kind='quicksort', order=None)
        Returns the indices that would sort an array.
        
        Perform an indirect sort along the given axis using the algorithm specified
        by the `kind` keyword. It returns an array of indices of the same shape as
        `a` that index data along the given axis in sorted order.
        
        Parameters
        ----------
        a : array_like
            Array to sort.
        axis : int or None, optional
            Axis along which to sort.  The default is -1 (the last axis). If None,
            the flattened array is used.
        kind : {'quicksort', 'mergesort', 'heapsort'}, optional
            Sorting algorithm.
        order : list, optional
            When `a` is an array with fields defined, this argument specifies
            which fields to compare first, second, etc.  Not all fields need be
            specified.
        
        Returns
        -------
        index_array : ndarray, int
            Array of indices that sort `a` along the specified axis.
            In other words, ``a[index_array]`` yields a sorted `a`.
        
        See Also
        --------
        sort : Describes sorting algorithms used.
        lexsort : Indirect stable sort with multiple keys.
        ndarray.sort : Inplace sort.
        
        Notes
        -----
        See `sort` for notes on the different sorting algorithms.
        
        As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
        nan values. The enhanced sort order is documented in `sort`.
        
        Examples
        --------
        One dimensional array:
        
        >>> x = np.array([3, 1, 2])
        >>> np.argsort(x)
        array([1, 2, 0])
        
        Two-dimensional array:
        
        >>> x = np.array([[0, 3], [2, 2]])
        >>> x
        array([[0, 3],
               [2, 2]])
        
        >>> np.argsort(x, axis=0)
        array([[0, 1],
               [1, 0]])
        
        >>> np.argsort(x, axis=1)
        array([[0, 1],
               [0, 1]])
        
        Sorting with keys:
        
        >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])
        >>> x
        array([(1, 0), (0, 1)],
              dtype=[('x', '<i4'), ('y', '<i4')])
        
        >>> np.argsort(x, order=('x','y'))
        array([1, 0])
        
        >>> np.argsort(x, order=('y','x'))
        array([0, 1])
    
    array(...)
        array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0)
        
        Create an array.
        
        Parameters
        ----------
        object : array_like
            An array, any object exposing the array interface, an
            object whose __array__ method returns an array, or any
            (nested) sequence.
        dtype : data-type, optional
            The desired data-type for the array.  If not given, then
            the type will be determined as the minimum type required
            to hold the objects in the sequence.  This argument can only
            be used to 'upcast' the array.  For downcasting, use the
            .astype(t) method.
        copy : bool, optional
            If true (default), then the object is copied.  Otherwise, a copy
            will only be made if __array__ returns a copy, if obj is a
            nested sequence, or if a copy is needed to satisfy any of the other
            requirements (`dtype`, `order`, etc.).
        order : {'C', 'F', 'A'}, optional
            Specify the order of the array.  If order is 'C' (default), then the
            array will be in C-contiguous order (last-index varies the
            fastest).  If order is 'F', then the returned array
            will be in Fortran-contiguous order (first-index varies the
            fastest).  If order is 'A', then the returned array may
            be in any order (either C-, Fortran-contiguous, or even
            discontiguous).
        subok : bool, optional
            If True, then sub-classes will be passed-through, otherwise
            the returned array will be forced to be a base-class array (default).
        ndmin : int, optional
            Specifies the minimum number of dimensions that the resulting
            array should have.  Ones will be pre-pended to the shape as
            needed to meet this requirement.
        
        Examples
        --------
        >>> np.array([1, 2, 3])
        array([1, 2, 3])
        
        Upcasting:
        
        >>> np.array([1, 2, 3.0])
        array([ 1.,  2.,  3.])
        
        More than one dimension:
        
        >>> np.array([[1, 2], [3, 4]])
        array([[1, 2],
               [3, 4]])
        
        Minimum dimensions 2:
        
        >>> np.array([1, 2, 3], ndmin=2)
        array([[1, 2, 3]])
        
        Type provided:
        
        >>> np.array([1, 2, 3], dtype=complex)
        array([ 1.+0.j,  2.+0.j,  3.+0.j])
        
        Data-type consisting of more than one element:
        
        >>> x = np.array([(1,2),(3,4)],dtype=[('a','<i4'),('b','<i4')])
        >>> x['a']
        array([1, 3])
        
        Creating an array from sub-classes:
        
        >>> np.array(np.mat('1 2; 3 4'))
        array([[1, 2],
               [3, 4]])
        
        >>> np.array(np.mat('1 2; 3 4'), subok=True)
        matrix([[1, 2],
                [3, 4]])
    
    asarray(a, dtype=None, order=None)
        Convert the input to an array.
        
        Parameters
        ----------
        a : array_like
            Input data, in any form that can be converted to an array.  This
            includes lists, lists of tuples, tuples, tuples of tuples, tuples
            of lists and ndarrays.
        dtype : data-type, optional
            By default, the data-type is inferred from the input data.
        order : {'C', 'F'}, optional
            Whether to use row-major ('C') or column-major ('F' for FORTRAN)
            memory representation.  Defaults to 'C'.
        
        Returns
        -------
        out : ndarray
            Array interpretation of `a`.  No copy is performed if the input
            is already an ndarray.  If `a` is a subclass of ndarray, a base
            class ndarray is returned.
        
        See Also
        --------
        asanyarray : Similar function which passes through subclasses.
        ascontiguousarray : Convert input to a contiguous array.
        asfarray : Convert input to a floating point ndarray.
        asfortranarray : Convert input to an ndarray with column-major
                         memory order.
        asarray_chkfinite : Similar function which checks input for NaNs and Infs.
        fromiter : Create an array from an iterator.
        fromfunction : Construct an array by executing a function on grid
                       positions.
        
        Examples
        --------
        Convert a list into an array:
        
        >>> a = [1, 2]
        >>> np.asarray(a)
        array([1, 2])
        
        Existing arrays are not copied:
        
        >>> a = np.array([1, 2])
        >>> np.asarray(a) is a
        True
        
        If `dtype` is set, array is copied only if dtype does not match:
        
        >>> a = np.array([1, 2], dtype=np.float32)
        >>> np.asarray(a, dtype=np.float32) is a
        True
        >>> np.asarray(a, dtype=np.float64) is a
        False
        
        Contrary to `asanyarray`, ndarray subclasses are not passed through:
        
        >>> issubclass(np.matrix, np.ndarray)
        True
        >>> a = np.matrix([[1, 2]])
        >>> np.asarray(a) is a
        False
        >>> np.asanyarray(a) is a
        True
    
    atleast_1d(*arys)
        Convert inputs to arrays with at least one dimension.
        
        Scalar inputs are converted to 1-dimensional arrays, whilst
        higher-dimensional inputs are preserved.
        
        Parameters
        ----------
        array1, array2, ... : array_like
            One or more input arrays.
        
        Returns
        -------
        ret : ndarray
            An array, or sequence of arrays, each with ``a.ndim >= 1``.
            Copies are made only if necessary.
        
        See Also
        --------
        atleast_2d, atleast_3d
        
        Examples
        --------
        >>> np.atleast_1d(1.0)
        array([ 1.])
        
        >>> x = np.arange(9.0).reshape(3,3)
        >>> np.atleast_1d(x)
        array([[ 0.,  1.,  2.],
               [ 3.,  4.,  5.],
               [ 6.,  7.,  8.]])
        >>> np.atleast_1d(x) is x
        True
        
        >>> np.atleast_1d(1, [3, 4])
        [array([1]), array([3, 4])]
    
    atleast_2d(*arys)
        View inputs as arrays with at least two dimensions.
        
        Parameters
        ----------
        array1, array2, ... : array_like
            One or more array-like sequences.  Non-array inputs are converted
            to arrays.  Arrays that already have two or more dimensions are
            preserved.
        
        Returns
        -------
        res, res2, ... : ndarray
            An array, or tuple of arrays, each with ``a.ndim >= 2``.
            Copies are avoided where possible, and views with two or more
            dimensions are returned.
        
        See Also
        --------
        atleast_1d, atleast_3d
        
        Examples
        --------
        >>> np.atleast_2d(3.0)
        array([[ 3.]])
        
        >>> x = np.arange(3.0)
        >>> np.atleast_2d(x)
        array([[ 0.,  1.,  2.]])
        >>> np.atleast_2d(x).base is x
        True
        
        >>> np.atleast_2d(1, [1, 2], [[1, 2]])
        [array([[1]]), array([[1, 2]]), array([[1, 2]])]
    
    band_stop_obj(wp, ind, passb, stopb, gpass, gstop, type)
        Band Stop Objective Function for order minimization
        
        Description:
        
          Returns the non-integer order for an analog band stop filter.
        
        Parameters
        ----------
        wp -- passb edge
        ind -- index specifying which passb edge to vary (0 or 1).
        passb -- two element vector of fixed passband edges.
        stopb -- two element vector of fixed stopband edges.
        gstop -- amount in dB of attenuation in stopband.
        gpass -- amount in dB of ripple in the passband.
        type -- 'butter', 'cheby', or 'ellip':
        
        Returns
        -------
        n -- filter order (possibly non-integer)
    
    barthann(M, sym=True)
        Return the M-point modified Bartlett-Hann window.
    
    bartlett(M, sym=True)
        The M-point Bartlett window.
    
    bessel(N, Wn, btype='low', analog=0, output='ba')
        Bessel digital and analog filter design.
        
        Description:
        
          Design an Nth order lowpass digital or analog Bessel filter
          and return the filter coefficients in (B,A) or (Z,P,K) form.
    
    besselap(N)
        Return (z,p,k) zero, pole, gain for analog prototype of an Nth
        order Bessel filter.
    
    bilinear(b, a, fs=1.0)
        Return a digital filter from an analog filter using the bilinear transform.
        
        The bilinear transform substitutes (z-1) / (z+1) for s
    
    blackman(M, sym=True)
        The M-point Blackman window.
    
    blackmanharris(M, sym=True)
        The M-point minimum 4-term Blackman-Harris window.
    
    bohman(M, sym=True)
        The M-point Bohman window.
    
    boxcar(M, sym=True)
        The M-point boxcar window.
    
    bspline(x, n)
        bspline(x,n):  B-spline basis function of order n.
        uses numpy.piecewise and automatic function-generator.
    
    buttap(N)
        Return (z,p,k) zero, pole, gain for analog prototype of an Nth
        order Butterworth filter.
    
    butter(N, Wn, btype='low', analog=0, output='ba')
        Butterworth digital and analog filter design.
        
        Description:
        
          Design an Nth order lowpass digital or analog Butterworth filter
          and return the filter coefficients in (B,A) or (Z,P,K) form.
        
        See also buttord.
    
    buttord(wp, ws, gpass, gstop, analog=0)
        Butterworth filter order selection.
        
        Return the order of the lowest order digital Butterworth filter that loses
        no more than gpass dB in the passband and has at least gstop dB attenuation
        in the stopband.
        
        Parameters
        ----------
        wp, ws -- Passband and stopband edge frequencies, normalized from 0
                  to 1 (1 corresponds to pi radians / sample).  For example:
                     Lowpass:   wp = 0.2,          ws = 0.3
                     Highpass:  wp = 0.3,          ws = 0.2
                     Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
                     Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]
        gpass -- The maximum loss in the passband (dB).
        gstop -- The minimum attenuation in the stopband (dB).
        analog -- Non-zero to design an analog filter (in this case wp and
                  ws are in radians / second).
        
        Returns
        -------
        ord -- The lowest order for a Butterworth filter which meets specs.
        Wn -- The Butterworth natural frequency (i.e. the "3dB frequency").
              Should be used with scipy.signal.butter to give filter results.
    
    c0_P(order)
    
    cascade(hk, J=7)
        (x,phi,psi) at dyadic points K/2**J from filter coefficients.
        
        Inputs:
          hk  -- coefficients of low-pass filter
          J   -- values will be computed at grid points $K/2^J$
        
        Outputs:
          x   -- the dyadic points $K/2^J$ for $K=0...N*(2^J)-1$
                  where len(hk)=len(gk)=N+1
          phi -- the scaling function phi(x) at x
                   $\phi(x) = \sum_{k=0}^{N} h_k \phi(2x-k)$
          psi -- the wavelet function psi(x) at x
                   $\psi(x) = \sum_{k=0}^N g_k \phi(2x-k)$
                 Only returned if gk is not None
        
        Algorithm:
        
          Uses the vector cascade algorithm described by Strang and Nguyen in
          "Wavelets and Filter Banks"
        
          Builds a dictionary of values and slices for quick reuse.
          Then inserts vectors into final vector at then end
    
    cheb1ap(N, rp)
        Return (z,p,k) zero, pole, gain for Nth order Chebyshev type I
        lowpass analog filter prototype with rp decibels of ripple
        in the passband.
    
    cheb1ord(wp, ws, gpass, gstop, analog=0)
        Chebyshev type I filter order selection.
        
        Return the order of the lowest order digital Chebyshev Type I filter that
        loses no more than gpass dB in the passband and has at least gstop dB
        attenuation in the stopband.
        
        Parameters
        ----------
        wp, ws -- Passband and stopband edge frequencies, normalized from 0
                  to 1 (1 corresponds to pi radians / sample).  For example:
                     Lowpass:   wp = 0.2,          ws = 0.3
                     Highpass:  wp = 0.3,          ws = 0.2
                     Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
                     Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]
        gpass -- The maximum loss in the passband (dB).
        gstop -- The minimum attenuation in the stopband (dB).
        analog -- Non-zero to design an analog filter (in this case wp and
                  ws are in radians / second).
        
        Returns
        -------
        ord -- The lowest order for a Chebyshev type I filter that meets specs.
        Wn -- The Chebyshev natural frequency (the "3dB frequency") for
              use with scipy.signal.cheby1 to give filter results.
    
    cheb2ap(N, rs)
        Return (z,p,k) zero, pole, gain for Nth order Chebyshev type II
        lowpass analog filter prototype with rs decibels of ripple
        in the stopband.
    
    cheb2ord(wp, ws, gpass, gstop, analog=0)
        Chebyshev type II filter order selection.
        
        Description:
        
          Return the order of the lowest order digital Chebyshev Type II filter
          that loses no more than gpass dB in the passband and has at least gstop dB
          attenuation in the stopband.
        
        Parameters
        ----------
        wp, ws -- Passband and stopband edge frequencies, normalized from 0
                  to 1 (1 corresponds to pi radians / sample).  For example:
                     Lowpass:   wp = 0.2,          ws = 0.3
                     Highpass:  wp = 0.3,          ws = 0.2
                     Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
                     Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]
        gpass -- The maximum loss in the passband (dB).
        gstop -- The minimum attenuation in the stopband (dB).
        analog -- Non-zero to design an analog filter (in this case wp and
                  ws are in radians / second).
        
        Returns
        -------
        ord -- The lowest order for a Chebyshev type II filter that meets specs.
        Wn -- The Chebyshev natural frequency for
              use with scipy.signal.cheby2 to give the filter.
    
    chebwin(M, at, sym=True)
        Dolph-Chebyshev window.
        
        INPUTS:
        
          M : int
            Window size
          at : float
            Attenuation (in dB)
          sym : bool
            Generates symmetric window if True.
    
    cheby1(N, rp, Wn, btype='low', analog=0, output='ba')
        Chebyshev type I digital and analog filter design.
        
        Description:
        
          Design an Nth order lowpass digital or analog Chebyshev type I filter
          and return the filter coefficients in (B,A) or (Z,P,K) form.
        
        See also cheb1ord.
    
    cheby2(N, rs, Wn, btype='low', analog=0, output='ba')
        Chebyshev type I digital and analog filter design.
        
        Description:
        
          Design an Nth order lowpass digital or analog Chebyshev type I filter
          and return the filter coefficients in (B,A) or (Z,P,K) form.
        
        See also cheb2ord.
    
    chirp(t, f0, t1, f1, method='linear', phi=0, vertex_zero=True, qshape=None)
        Frequency-swept cosine generator.
        
        In the following, 'Hz' should be interpreted as 'cycles per time unit';
        there is no assumption here that the time unit is one second.  The
        important distinction is that the units of rotation are cycles, not
        radians.
        
        Parameters
        ----------
        t : ndarray
            Times at which to evaluate the waveform.
        f0 : float
            Frequency (in Hz) at time t=0.
        t1 : float
            Time at which `f1` is specified.
        f1 : float
            Frequency (in Hz) of the waveform at time `t1`.
        method : {'linear', 'quadratic', 'logarithmic', 'hyperbolic'}, optional
            Kind of frequency sweep.  If not given, `linear` is assumed.  See
            Notes below for more details.
        phi : float, optional
            Phase offset, in degrees. Default is 0.
        vertex_zero : bool, optional
            This parameter is only used when `method` is 'quadratic'.
            It determines whether the vertex of the parabola that is the graph
            of the frequency is at t=0 or t=t1.
        qshape : str (deprecated)
            If `method` is `quadratic` and `qshape` is not None, chirp() will
            use scipy.signal.waveforms.old_chirp to compute the wave form.
            This parameter is deprecated, and will be removed in SciPy 0.9.
        
        Returns
        -------
        A numpy array containing the signal evaluated at 't' with the requested
        time-varying frequency.  More precisely, the function returns:
        
            ``cos(phase + (pi/180)*phi)``
        
        where `phase` is the integral (from 0 to t) of ``2*pi*f(t)``.
        ``f(t)`` is defined below.
        
        See Also
        --------
        scipy.signal.waveforms.sweep_poly
        
        Notes
        -----
        There are four options for the `method`.  The following formulas give
        the instantaneous frequency (in Hz) of the signal generated by
        `chirp()`.  For convenience, the shorter names shown below may also be
        used.
        
        linear, lin, li:
        
            ``f(t) = f0 + (f1 - f0) * t / t1``
        
        quadratic, quad, q:
        
            The graph of the frequency f(t) is a parabola through (0, f0) and
            (t1, f1).  By default, the vertex of the parabola is at (0, f0).
            If `vertex_zero` is False, then the vertex is at (t1, f1).  The
            formula is:
        
            if vertex_zero is True:
        
                ``f(t) = f0 + (f1 - f0) * t**2 / t1**2``
        
            else:
        
                ``f(t) = f1 - (f1 - f0) * (t1 - t)**2 / t1**2``
        
            To use a more general quadratic function, or an arbitrary
            polynomial, use the function `scipy.signal.waveforms.sweep_poly`.
        
        logarithmic, log, lo:
        
            ``f(t) = f0 * (f1/f0)**(t/t1)``
        
            f0 and f1 must be nonzero and have the same sign.
        
            This signal is also known as a geometric or exponential chirp.
        
        hyperbolic, hyp:
        
            ``f(t) = f0*f1*t1 / ((f0 - f1)*t + f1*t1)``
        
            f1 must be positive, and f0 must be greater than f1.
    
    cmplx_sort(p)
        sort roots based on magnitude.
    
    comb(N, k, exact=0)
        Combinations of N things taken k at a time.
        
        Parameters
        ----------
        N : int, array
            Nunmber of things.
        k : int, array
            Numner of elements taken.
        exact : int, optional
            If exact is 0, then floating point precision is used, otherwise
            exact long integer is computed.
        
        Returns
        -------
        val : int, array
            The total number of combinations.
        
        Notes
        -----
        - Array arguments accepted only for exact=0 case.
        - If k > N, N < 0, or k < 0, then a 0 is returned.
    
    convolve(in1, in2, mode='full', old_behavior=True)
        Convolve two N-dimensional arrays.
        
        Convolve in1 and in2 with output size determined by mode.
        
        Parameters
        ----------
        in1: array
            first input.
        in2: array
            second input. Should have the same number of dimensions as in1.
        mode: str {'valid', 'same', 'full'}
            a string indicating the size of the output:
        
            ``valid`` : the output consists only of those elements that do not
               rely on the zero-padding.
        
            ``same`` : the output is the same size as the largest input centered
               with respect to the 'full' output.
        
            ``full`` : the output is the full discrete linear cross-correlation
               of the inputs. (Default)
        
        
        Returns
        -------
        out: array
            an N-dimensional array containing a subset of the discrete linear
            cross-correlation of in1 with in2.
    
    convolve2d(in1, in2, mode='full', boundary='fill', fillvalue=0, old_behavior=True)
        Convolve two 2-dimensional arrays.
        
        Description:
        
           Convolve in1 and in2 with output size determined by mode and boundary
           conditions determined by boundary and fillvalue.
        
        Inputs:
        
          in1 -- a 2-dimensional array.
          in2 -- a 2-dimensional array.
          mode -- a flag indicating the size of the output
                  'valid'  (0): The output consists only of those elements that
                                  do not rely on the zero-padding.
                  'same'   (1): The output is the same size as the input centered
                                  with respect to the 'full' output.
                  'full'   (2): The output is the full discrete linear convolution
                                  of the inputs. (*Default*)
          boundary -- a flag indicating how to handle boundaries
                      'fill' : pad input arrays with fillvalue. (*Default*)
                      'wrap' : circular boundary conditions.
                      'symm' : symmetrical boundary conditions.
          fillvalue -- value to fill pad input arrays with (*Default* = 0)
        
        Outputs:  (out,)
        
          out -- a 2-dimensional array containing a subset of the discrete linear
                 convolution of in1 with in2.
    
    correlate(in1, in2, mode='full', old_behavior=True)
        Cross-correlate two N-dimensional arrays.
        
        Cross-correlate in1 and in2 with the output size determined by the mode
        argument.
        
        Parameters
        ----------
        in1: array
            first input.
        in2: array
            second input. Should have the same number of dimensions as in1.
        mode: str {'valid', 'same', 'full'}
            a string indicating the size of the output:
                - 'valid': the output consists only of those elements that do not
                rely on the zero-padding.
                - 'same': the output is the same size as the largest input centered
                  with respect to the 'full' output.
                - 'full': the output is the full discrete linear cross-correlation
                  of the inputs. (Default)
        old_behavior: bool
            If True (default), the old behavior of correlate is implemented:
                - if in1.size < in2.size, in1 and in2 are swapped (correlate(in1,
                  in2) == correlate(in2, in1))
                - For complex inputs, the conjugate is not taken for in2
            If False, the new, conventional definition of correlate is implemented.
        
        Returns
        -------
        out: array
            an N-dimensional array containing a subset of the discrete linear
            cross-correlation of in1 with in2.
        
        Notes
        -----
        The correlation z of two arrays x and y of rank d is defined as
        
          z[...,k,...] = sum[..., i_l, ...]
                x[..., i_l,...] * conj(y[..., i_l + k,...])
    
    correlate2d(in1, in2, mode='full', boundary='fill', fillvalue=0, old_behavior=True)
        Cross-correlate two 2-dimensional arrays.
        
        Description:
        
           Cross correlate in1 and in2 with output size determined by mode
           and boundary conditions determined by boundary and fillvalue.
        
        Inputs:
        
          in1 -- a 2-dimensional array.
          in2 -- a 2-dimensional array.
          mode -- a flag indicating the size of the output
                  'valid'  (0): The output consists only of those elements that
                                  do not rely on the zero-padding.
                  'same'   (1): The output is the same size as the input centered
                                  with respect to the 'full' output.
                  'full'   (2): The output is the full discrete linear convolution
                                  of the inputs. (*Default*)
          boundary -- a flag indicating how to handle boundaries
                      'fill' : pad input arrays with fillvalue. (*Default*)
                      'wrap' : circular boundary conditions.
                      'symm' : symmetrical boundary conditions.
          fillvalue -- value to fill pad input arrays with (*Default* = 0)
        
        Outputs:  (out,)
        
          out -- a 2-dimensional array containing a subset of the discrete linear
                 cross-correlation of in1 with in2.
    
    cspline1d(signal, lamb=0.0)
        Compute cubic spline coefficients for rank-1 array.
        
        Description:
        
          Find the cubic spline coefficients for a 1-D signal assuming
          mirror-symmetric boundary conditions.   To obtain the signal back from
          the spline representation mirror-symmetric-convolve these coefficients
          with a length 3 FIR window [1.0, 4.0, 1.0]/ 6.0 .
        
        Inputs:
        
          signal -- a rank-1 array representing samples of a signal.
          lamb -- smoothing coefficient (default = 0.0)
        
        Output:
        
          c -- cubic spline coefficients.
    
    cspline1d_eval(cj, newx, dx=1.0, x0=0)
        Evaluate a spline at the new set of points.
        dx is the old sample-spacing while x0 was the old origin.
        
        In other-words the old-sample points (knot-points) for which the cj
        represent spline coefficients were at equally-spaced points of
        
        oldx = x0 + j*dx  j=0...N-1
        
        N=len(cj)
        
        edges are handled using mirror-symmetric boundary conditions.
    
    cspline2d(...)
        cspline2d(input {, lambda, precision}) -> ck
        
        Description:
        
          Return the third-order B-spline coefficients over a regularly spacedi
          input grid for the two-dimensional input image.  The lambda argument
          specifies the amount of smoothing.  The precision argument allows specifying
          the precision used when computing the infinite sum needed to apply mirror-
          symmetric boundary conditions.
    
    cubic(x)
        Special case of bspline.  Equivalent to bspline(x,3).
    
    daub(p)
        The coefficients for the FIR low-pass filter producing Daubechies wavelets.
        
        p>=1 gives the order of the zero at f=1/2.
        There are 2p filter coefficients.
        
        Parameters
        ----------
        p : int
            Order of the zero at f=1/2, can have values from 1 to 34.
    
    decimate(x, q, n=None, ftype='iir', axis=-1)
        downsample the signal x by an integer factor q, using an order n filter
        
        By default an order 8 Chebyshev type I filter is used or a 30 point FIR
        filter with hamming window if ftype is 'fir'.
        
        Parameters
        ----------
        x : N-d array
          the signal to be downsampled
        q : int
          the downsampling factor
        n : int or None
          the order of the filter (1 less than the length for 'fir')
        ftype : {'iir' or 'fir'}
          the type of the lowpass filter
        axis : int
          the axis along which to decimate
        
        Returns
        -------
        y : N-d array
          the down-sampled signal
        
        See also:  resample
    
    deconvolve(signal, divisor)
        Deconvolves divisor out of signal.
    
    detrend(data, axis=-1, type='linear', bp=0)
        Remove linear trend along axis from data.
        
        If type is 'constant' then remove mean only.
        
        If bp is given, then it is a sequence of points at which to
           break a piecewise-linear fit to the data.
    
    diag(v, k=0)
        Extract a diagonal or construct a diagonal array.
        
        Parameters
        ----------
        v : array_like
            If `v` is a 2-D array, return a copy of its `k`-th diagonal.
            If `v` is a 1-D array, return a 2-D array with `v` on the `k`-th
            diagonal.
        k : int, optional
            Diagonal in question. The default is 0. Use `k>0` for diagonals
            above the main diagonal, and `k<0` for diagonals below the main
            diagonal.
        
        Returns
        -------
        out : ndarray
            The extracted diagonal or constructed diagonal array.
        
        See Also
        --------
        diagonal : Return specified diagonals.
        diagflat : Create a 2-D array with the flattened input as a diagonal.
        trace : Sum along diagonals.
        triu : Upper triangle of an array.
        tril : Lower triange of an array.
        
        Examples
        --------
        >>> x = np.arange(9).reshape((3,3))
        >>> x
        array([[0, 1, 2],
               [3, 4, 5],
               [6, 7, 8]])
        
        >>> np.diag(x)
        array([0, 4, 8])
        >>> np.diag(x, k=1)
        array([1, 5])
        >>> np.diag(x, k=-1)
        array([3, 7])
        
        >>> np.diag(np.diag(x))
        array([[0, 0, 0],
               [0, 4, 0],
               [0, 0, 8]])
    
    dot(...)
        dot(a, b)
        
        Dot product of two arrays.
        
        For 2-D arrays it is equivalent to matrix multiplication, and for 1-D
        arrays to inner product of vectors (without complex conjugation). For
        N dimensions it is a sum product over the last axis of `a` and
        the second-to-last of `b`::
        
            dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
        
        Parameters
        ----------
        a : array_like
            First argument.
        b : array_like
            Second argument.
        
        Returns
        -------
        output : ndarray
            Returns the dot product of `a` and `b`.  If `a` and `b` are both
            scalars or both 1-D arrays then a scalar is returned; otherwise
            an array is returned.
        
        Raises
        ------
        ValueError
            If the last dimension of `a` is not the same size as
            the second-to-last dimension of `b`.
        
        See Also
        --------
        vdot : Complex-conjugating dot product.
        tensordot : Sum products over arbitrary axes.
        
        Examples
        --------
        >>> np.dot(3, 4)
        12
        
        Neither argument is complex-conjugated:
        
        >>> np.dot([2j, 3j], [2j, 3j])
        (-13+0j)
        
        For 2-D arrays it's the matrix product:
        
        >>> a = [[1, 0], [0, 1]]
        >>> b = [[4, 1], [2, 2]]
        >>> np.dot(a, b)
        array([[4, 1],
               [2, 2]])
        
        >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
        >>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
        >>> np.dot(a, b)[2,3,2,1,2,2]
        499128
        >>> sum(a[2,3,2,:] * b[1,2,:,2])
        499128
    
    ellip(N, rp, rs, Wn, btype='low', analog=0, output='ba')
        Elliptic (Cauer) digital and analog filter design.
        
        Description:
        
          Design an Nth order lowpass digital or analog elliptic filter
          and return the filter coefficients in (B,A) or (Z,P,K) form.
        
        See also ellipord.
    
    ellipap(N, rp, rs)
        Return (z,p,k) zeros, poles, and gain of an Nth order normalized
        prototype elliptic analog lowpass filter with rp decibels of ripple
        in the passband and a stopband rs decibels down.
        
        See Chapter 12 and Chapter 5 of "Filter Design for Signal Processing",
        by Lutova, Tosic, and Evans.  This is
    
    ellipord(wp, ws, gpass, gstop, analog=0)
        Elliptic (Cauer) filter order selection.
        
        Return the order of the lowest order digital elliptic filter that loses no
        more than gpass dB in the passband and has at least gstop dB attenuation in
        the stopband.
        
        Parameters
        ----------
        wp, ws -- Passband and stopband edge frequencies, normalized from 0
                  to 1 (1 corresponds to pi radians / sample).  For example:
                     Lowpass:   wp = 0.2,          ws = 0.3
                     Highpass:  wp = 0.3,          ws = 0.2
                     Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
                     Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]
        gpass -- The maximum loss in the passband (dB).
        gstop -- The minimum attenuation in the stopband (dB).
        analog -- Non-zero to design an analog filter (in this case wp and
                  ws are in radians / second).
        
        Returns
        -------
        ord -- The lowest order for an Elliptic (Cauer) filter that meets specs.
        Wn  -- The natural frequency for use with scipy.signal.ellip
                 to give the filter.
    
    expand_dims(a, axis)
        Expand the shape of an array.
        
        Insert a new axis, corresponding to a given position in the array shape.
        
        Parameters
        ----------
        a : array_like
            Input array.
        axis : int
            Position (amongst axes) where new axis is to be inserted.
        
        Returns
        -------
        res : ndarray
            Output array. The number of dimensions is one greater than that of
            the input array.
        
        See Also
        --------
        doc.indexing, atleast_1d, atleast_2d, atleast_3d
        
        Examples
        --------
        >>> x = np.array([1,2])
        >>> x.shape
        (2,)
        
        The following is equivalent to ``x[np.newaxis,:]`` or ``x[np.newaxis]``:
        
        >>> y = np.expand_dims(x, axis=0)
        >>> y
        array([[1, 2]])
        >>> y.shape
        (1, 2)
        
        >>> y = np.expand_dims(x, axis=1)  # Equivalent to x[:,newaxis]
        >>> y
        array([[1],
               [2]])
        >>> y.shape
        (2, 1)
        
        Note that some examples may use ``None`` instead of ``np.newaxis``.  These
        are the same objects:
        
        >>> np.newaxis is None
        True
    
    extract(condition, arr)
        Return the elements of an array that satisfy some condition.
        
        This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
        `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.
        
        Parameters
        ----------
        condition : array_like
            An array whose nonzero or True entries indicate the elements of `arr`
            to extract.
        arr : array_like
            Input array of the same size as `condition`.
        
        See Also
        --------
        take, put, putmask, compress
        
        Examples
        --------
        >>> arr = np.arange(12).reshape((3, 4))
        >>> arr
        array([[ 0,  1,  2,  3],
               [ 4,  5,  6,  7],
               [ 8,  9, 10, 11]])
        >>> condition = np.mod(arr, 3)==0
        >>> condition
        array([[ True, False, False,  True],
               [False, False,  True, False],
               [False,  True, False, False]], dtype=bool)
        >>> np.extract(condition, arr)
        array([0, 3, 6, 9])
        
        
        If `condition` is boolean:
        
        >>> arr[condition]
        array([0, 3, 6, 9])
    
    eye(N, M=None, k=0, dtype=<type 'float'>)
        Return a 2-D array with ones on the diagonal and zeros elsewhere.
        
        Parameters
        ----------
        N : int
          Number of rows in the output.
        M : int, optional
          Number of columns in the output. If None, defaults to `N`.
        k : int, optional
          Index of the diagonal: 0 (the default) refers to the main diagonal,
          a positive value refers to an upper diagonal, and a negative value
          to a lower diagonal.
        dtype : data-type, optional
          Data-type of the returned array.
        
        Returns
        -------
        I : ndarray of shape (N,M)
          An array where all elements are equal to zero, except for the `k`-th
          diagonal, whose values are equal to one.
        
        See Also
        --------
        identity : (almost) equivalent function
        diag : diagonal 2-D array from a 1-D array specified by the user.
        
        Examples
        --------
        >>> np.eye(2, dtype=int)
        array([[1, 0],
               [0, 1]])
        >>> np.eye(3, k=1)
        array([[ 0.,  1.,  0.],
               [ 0.,  0.,  1.],
               [ 0.,  0.,  0.]])
    
    factorial(n, exact=0)
        n! = special.gamma(n+1)
        
        If exact==0, then floating point precision is used, otherwise
        exact long integer is computed.
        
        Notes:
          - Array argument accepted only for exact=0 case.
          - If n<0, the return value is 0.
    
    fft(x, n=None, axis=-1, overwrite_x=0)
        Return discrete Fourier transform of arbitrary type sequence x.
        
        Parameters
        ----------
        x : array-like
            array to fourier transform.
        n : int, optional
            Length of the Fourier transform. If n<x.shape[axis],
            x is truncated. If n>x.shape[axis], x is zero-padded.
            (Default n=x.shape[axis]).
        axis : int, optional
            Axis along which the fft's are computed. (default=-1)
        overwrite_x : bool, optional
            If True the contents of x can be destroyed. (default=False)
        
        Returns
        -------
        z : complex ndarray
            with the elements:
                [y(0),y(1),..,y(n/2-1),y(-n/2),...,y(-1)]        if n is even
                [y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd
            where
                y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k* 2*pi/n), j = 0..n-1
            Note that y(-j) = y(n-j).conjugate().
        
        See Also
        --------
        ifft : Inverse FFT
        rfft : FFT of a real sequence
        
        Notes
        -----
        The packing of the result is "standard": If A = fft(a, n), then A[0]
        contains the zero-frequency term, A[1:n/2+1] contains the
        positive-frequency terms, and A[n/2+1:] contains the negative-frequency
        terms, in order of decreasingly negative frequency. So for an 8-point
        transform, the frequencies of the result are [ 0, 1, 2, 3, 4, -3, -2, -1].
        
        This is most efficient for n a power of two.
        
        .. note:: In scipy 0.8.0 `fft` in single precision is available, but *only*
            for input array sizes which can be factorized into (combinations of) 2,
            3 and 5. For other sizes the computation will be done in double
            precision.
        
        Examples
        --------
        >>> x = np.arange(5)
        >>> np.all(np.abs(x-fft(ifft(x))<1.e-15) #within numerical accuracy.
        True
    
    fft2(x, shape=None, axes=(-2, -1), overwrite_x=0)
        2-D discrete Fourier transform.
        
        Return the two-dimensional discrete Fourier transform of the 2-D argument
        `x`.
        
        See Also
        --------
        fftn : for detailed information.
    
    fftconvolve(in1, in2, mode='full')
        Convolve two N-dimensional arrays using FFT. See convolve.
    
    fftfreq(n, d=1.0)
        Return the Discrete Fourier Transform sample frequencies.
        
        The returned float array contains the frequency bins in
        cycles/unit (with zero at the start) given a window length `n` and a
        sample spacing `d`::
        
          f = [0, 1, ..., n/2-1, -n/2, ..., -1] / (d*n)         if n is even
          f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd
        
        Parameters
        ----------
        n : int
            Window length.
        d : scalar
            Sample spacing.
        
        Returns
        -------
        out : ndarray
            The array of length `n`, containing the sample frequencies.
        
        Examples
        --------
        >>> signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)
        >>> fourier = np.fft.fft(signal)
        >>> n = signal.size
        >>> timestep = 0.1
        >>> freq = np.fft.fftfreq(n, d=timestep)
        >>> freq
        array([ 0.  ,  1.25,  2.5 ,  3.75, -5.  , -3.75, -2.5 , -1.25])
    
    fftn(x, shape=None, axes=None, overwrite_x=0)
        fftn(x, shape=None, axes=None, overwrite_x=0) -> y
        
        Return multi-dimensional discrete Fourier transform of arbitrary
        type sequence x.
        
        The returned array contains
        
          y[j_1,..,j_d] = sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
             x[k_1,..,k_d] * prod[i=1..d] exp(-sqrt(-1)*2*pi/n_i * j_i * k_i)
        
        where d = len(x.shape) and n = x.shape.
        Note that y[..., -j_i, ...] = y[..., n_i-j_i, ...].conjugate().
        
        Optional input:
          shape
            Defines the shape of the Fourier transform. If shape is not
            specified then shape=take(x.shape,axes,axis=0).
            If shape[i]>x.shape[i] then the i-th dimension is padded with
            zeros. If shape[i]<x.shape[i], then the i-th dimension is
            truncated to desired length shape[i].
          axes
            The transform is applied along the given axes of the input
            array (or the newly constructed array if shape argument was
            used).
          overwrite_x
            If set to true, the contents of x can be destroyed.
        
        Notes:
          y == fftn(ifftn(y)) within numerical accuracy.
    
    filtfilt(b, a, x)
    
    findfreqs(num, den, N)
    
    firwin(N, cutoff, width=None, window='hamming')
        FIR Filter Design using windowed ideal filter method.
        
        Parameters
        ----------
        N      -- order of filter (number of taps)
        cutoff -- cutoff frequency of filter (normalized so that 1 corresponds to
                  Nyquist or pi radians / sample)
        
        width  -- if width is not None, then assume it is the approximate width of
                  the transition region (normalized so that 1 corresonds to pi)
                  for use in kaiser FIR filter design.
        window -- desired window to use. See get_window for a list
                  of windows and required parameters.
        
        Returns
        -------
        h      -- coefficients of length N fir filter.
    
    flattop(M, sym=True)
        The M-point Flat top window.
    
    flipud(m)
        Flip array in the up/down direction.
        
        Flip the entries in each column in the up/down direction.
        Rows are preserved, but appear in a different order than before.
        
        Parameters
        ----------
        m : array_like
            Input array.
        
        Returns
        -------
        out : array_like
            A view of `m` with the rows reversed.  Since a view is
            returned, this operation is :math:`\mathcal O(1)`.
        
        See Also
        --------
        fliplr : Flip array in the left/right direction.
        rot90 : Rotate array counterclockwise.
        
        Notes
        -----
        Equivalent to ``A[::-1,...]``.
        Does not require the array to be two-dimensional.
        
        Examples
        --------
        >>> A = np.diag([1.0, 2, 3])
        >>> A
        array([[ 1.,  0.,  0.],
               [ 0.,  2.,  0.],
               [ 0.,  0.,  3.]])
        >>> np.flipud(A)
        array([[ 0.,  0.,  3.],
               [ 0.,  2.,  0.],
               [ 1.,  0.,  0.]])
        
        >>> A = np.random.randn(2,3,5)
        >>> np.all(np.flipud(A)==A[::-1,...])
        True
        
        >>> np.flipud([1,2])
        array([2, 1])
    
    freqs(b, a, worN=None, plot=None)
        Compute frequency response of analog filter.
        
        Given the numerator (b) and denominator (a) of a filter compute its
        frequency response.
        
                b[0]*(jw)**(nb-1) + b[1]*(jw)**(nb-2) + ... + b[nb-1]
        H(w) = --------------------------------------------------------
                a[0]*(jw)**(na-1) + a[1]*(jw)**(na-2) + ... + a[na-1]
        
        Parameters
        ----------
        b : ndarray
            numerator of a linear filter
        a : ndarray
            numerator of a linear filter
        worN : {None, int}, optional
            If None, then compute at 200 frequencies around the interesting parts
            of the response curve (determined by pole-zero locations).  If a single
            integer, the compute at that many frequencies.  Otherwise, compute the
            response at frequencies given in worN.
        
        Returns
        -------
        w : ndarray
            The frequencies at which h was computed.
        h : ndarray
            The frequency response.
    
    freqz(b, a=1, worN=None, whole=0, plot=None)
        Compute the frequency response of a digital filter.
        
        Given the numerator ``b`` and denominator ``a`` of a digital filter compute
        its frequency response::
        
                   jw               -jw            -jmw
            jw  B(e)    b[0] + b[1]e + .... + b[m]e
         H(e) = ---- = ------------------------------------
                   jw               -jw            -jnw
                A(e)    a[0] + a[1]e + .... + a[n]e
        
        Parameters
        ----------
        b : ndarray
            numerator of a linear filter
        a : ndarray
            numerator of a linear filter
        worN : {None, int}, optional
            If None, then compute at 512 frequencies around the unit circle.
            If a single integer, the compute at that many frequencies.
            Otherwise, compute the response at frequencies given in worN
        whole : {0,1}, optional
            Normally, frequencies are computed from 0 to pi (upper-half of
            unit-circle.  If whole is non-zero compute frequencies from 0 to 2*pi.
        
        Returns
        -------
        w : ndarray
            The frequencies at which h was computed.
        h : ndarray
            The frequency response.
        
        Examples
        --------
        
        >>> b = firwin(80, 0.5, window=('kaiser', 8))
        >>> h, w = freqz(b)
        
        >>> import matplotlib.pyplot as plt
        >>> fig = plt.figure()
        >>> plt.title('Digital filter frequency response')
        >>> ax1 = fig.add_subplot(111)
        
        >>> plt.semilogy(h, np.abs(w), 'b')
        >>> plt.ylabel('Amplitude (dB)', color='b')
        >>> plt.xlabel('Frequency (rad/sample)')
        >>> plt.grid()
        >>> plt.legend()
        
        >>> ax2 = ax1.twinx()
        >>> angles = np.unwrap(np.angle(w))
        >>> plt.plot(h, angles, 'g')
        >>> plt.ylabel('Angle (radians)', color='g')
        >>> plt.show()
    
    gauss_spline(x, n)
        Gaussian approximation to B-spline basis function of order n.
    
    gaussian(M, std, sym=True)
        Return a Gaussian window of length M with standard-deviation std.
    
    gausspulse(t, fc=1000, bw=0.5, bwr=-6, tpr=-60, retquad=0, retenv=0)
        Return a gaussian modulated sinusoid: exp(-a t^2) exp(1j*2*pi*fc).
        
        If `retquad` is non-zero, then return the real and imaginary parts
        (in-phase and quadrature)
        If `retenv` is non-zero, then return the envelope (unmodulated signal).
        Otherwise, return the real part of the modulated sinusoid.
        
        Parameters
        ----------
        t : ndarray
            Input array.
        fc : int, optional
            Center frequency (Hz).
        bw : float, optional
            Fractional bandwidth in frequency domain of pulse (Hz).
        bwr: float, optional
            Reference level at which fractional bandwidth is calculated (dB).
        tpr : float, optional
            If `t` is 'cutoff', then the function returns the cutoff
            time for when the pulse amplitude falls below `tpr` (in dB).
        retquad : int, optional
            Return the quadrature (imaginary) as well as the real part
            of the signal.
        retenv : int, optional
            Return the envelope of the signal.
    
    general_gaussian(M, p, sig, sym=True)
        Return a window with a generalized Gaussian shape.
        
        exp(-0.5*(x/sig)**(2*p))
        
        half power point is at (2*log(2)))**(1/(2*p))*sig
    
    get_window(window, Nx, fftbins=True)
        Return a window of length Nx and type window.
        
        If fftbins is True, create a "periodic" window ready to use with ifftshift
        and be multiplied by the result of an fft (SEE ALSO fftfreq).
        
        Window types:  boxcar, triang, blackman, hamming, hanning, bartlett,
                       parzen, bohman, blackmanharris, nuttall, barthann,
                       kaiser (needs beta), gaussian (needs std),
                       general_gaussian (needs power, width),
                       slepian (needs width), chebwin (needs attenuation)
        
        If the window requires no parameters, then it can be a string.
        If the window requires parameters, the window argument should be a tuple
            with the first argument the string name of the window, and the next
            arguments the needed parameters.
        If window is a floating point number, it is interpreted as the beta
            parameter of the kaiser window.
    
    hamming(M, sym=True)
        The M-point Hamming window.
    
    hann = hanning(M, sym=True)
        The M-point Hanning window.
    
    hanning(M, sym=True)
        The M-point Hanning window.
    
    hilbert(x, N=None, axis=-1)
        Compute the analytic signal.
        
        The transformation is done along the last axis by default.
        
        Parameters
        ----------
        x : array-like
            Signal data
        N : int, optional
            Number of Fourier components. Default: ``x.shape[axis]``
        axis : int, optional
            
        
        Returns
        -------
        xa : ndarray
            Analytic signal of `x`, of each 1d array along axis
        
        Notes
        -----
        The analytic signal `x_a(t)` of `x(t)` is::
        
            x_a = F^{-1}(F(x) 2U) = x + i y
        
        where ``F`` is the Fourier transform, ``U`` the unit step function,
        and ``y`` the Hilbert transform of ``x``. [1]
        
        changes in scipy 0.8.0: new axis argument, new default axis=-1
        
        References
        ----------
        .. [1] Wikipedia, "Analytic signal".
               http://en.wikipedia.org/wiki/Analytic_signal
    
    hilbert2(x, N=None)
        Compute the '2-D' analytic signal of `x`
        
        
        Parameters
        ----------
        x : array_like
            2-D signal data.
        N : int, optional
            Number of Fourier components. Default is ``x.shape``
        
        Returns
        -------
        xa : ndarray
            Analytic signal of `x` taken along axes (0,1).
        
        References
        ----------
        .. [1] Wikipedia, "Analytic signal",
            http://en.wikipedia.org/wiki/Analytic_signal
    
    ifft(x, n=None, axis=-1, overwrite_x=0)
        ifft(x, n=None, axis=-1, overwrite_x=0) -> y
        
        Return inverse discrete Fourier transform of arbitrary type
        sequence x.
        
        The returned complex array contains
          [y(0),y(1),...,y(n-1)]
        where
          y(j) = 1/n sum[k=0..n-1] x[k] * exp(sqrt(-1)*j*k* 2*pi/n)
        
        Optional input: see fft.__doc__
    
    ifft2(x, shape=None, axes=(-2, -1), overwrite_x=0)
        ifft2(x, shape=None, axes=(-2,-1), overwrite_x=0) -> y
        
        Return inverse two-dimensional discrete Fourier transform of
        arbitrary type sequence x.
        
        See ifftn.__doc__ for more information.
    
    ifftn(x, shape=None, axes=None, overwrite_x=0)
        Return inverse multi-dimensional discrete Fourier transform of
        arbitrary type sequence x.
        
        The returned array contains::
        
          y[j_1,..,j_d] = 1/p * sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
             x[k_1,..,k_d] * prod[i=1..d] exp(sqrt(-1)*2*pi/n_i * j_i * k_i)
        
        where ``d = len(x.shape)``, ``n = x.shape``, and ``p = prod[i=1..d] n_i``.
        
        For description of parameters see `fftn`.
        
        See Also
        --------
        fftn : for detailed information.
    
    ifftshift(x, axes=None)
        The inverse of fftshift.
        
        Parameters
        ----------
        x : array_like
            Input array.
        axes : int or shape tuple, optional
            Axes over which to calculate.  Defaults to None, which shifts all axes.
        
        Returns
        -------
        y : ndarray
            The shifted array.
        
        See Also
        --------
        fftshift : Shift zero-frequency component to the center of the spectrum.
        
        Examples
        --------
        >>> freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)
        >>> freqs
        array([[ 0.,  1.,  2.],
               [ 3.,  4., -4.],
               [-3., -2., -1.]])
        >>> np.fft.ifftshift(np.fft.fftshift(freqs))
        array([[ 0.,  1.,  2.],
               [ 3.,  4., -4.],
               [-3., -2., -1.]])
    
    iirdesign(wp, ws, gpass, gstop, analog=0, ftype='ellip', output='ba')
        Complete IIR digital and analog filter design.
        
        Given passband and stopband frequencies and gains construct an analog or
        digital IIR filter of minimum order for a given basic type.  Return the
        output in numerator, denominator ('ba') or pole-zero ('zpk') form.
        
        Parameters
        ----------
        wp, ws -- Passband and stopband edge frequencies, normalized from 0
                  to 1 (1 corresponds to pi radians / sample).  For example:
                     Lowpass:   wp = 0.2,          ws = 0.3
                     Highpass:  wp = 0.3,          ws = 0.2
                     Bandpass:  wp = [0.2, 0.5],   ws = [0.1, 0.6]
                     Bandstop:  wp = [0.1, 0.6],   ws = [0.2, 0.5]
        gpass -- The maximum loss in the passband (dB).
        gstop -- The minimum attenuation in the stopband (dB).
        analog -- Non-zero to design an analog filter (in this case wp and
                  ws are in radians / second).
        ftype -- The type of iir filter to design:
                   elliptic    : 'ellip'
                   Butterworth : 'butter',
                   Chebyshev I : 'cheby1',
                   Chebyshev II: 'cheby2',
                   Bessel :      'bessel'
        output -- Type of output:  numerator/denominator ('ba') or pole-zero ('zpk')
        
        Returns
        -------
          b,a -- Numerator and denominator of the iir filter.
          z,p,k -- Zeros, poles, and gain of the iir filter.
    
    iirfilter(N, Wn, rp=None, rs=None, btype='band', analog=0, ftype='butter', output='ba')
        IIR digital and analog filter design given order and critical points.
        
        Design an Nth order lowpass digital or analog filter and return the filter
        coefficients in (B,A) (numerator, denominator) or (Z,P,K) form.
        
        Parameters
        ----------
        N -- the order of the filter.
        Wn -- a scalar or length-2 sequence giving the critical frequencies.
        rp, rs -- For chebyshev and elliptic filters provides the maximum ripple
                  in the passband and the minimum attenuation in the stop band.
        btype -- the type of filter (lowpass, highpass, bandpass, or bandstop).
        analog -- non-zero to return an analog filter, otherwise
                  a digital filter is returned.
        ftype -- the type of IIR filter (Butterworth, Cauer (Elliptic),
                 Bessel, Chebyshev1, Chebyshev2)
        output -- 'ba' for (b,a) output, 'zpk' for (z,p,k) output.
        
        SEE ALSO butterord, cheb1ord, cheb2ord, ellipord
    
    impulse(system, X0=None, T=None, N=None)
        Impulse response of continuous-time system.
        
        Parameters
        ----------
        system : LTI class or tuple
            If specified as a tuple, the system is described as
            ``(num, den)``, ``(zero, pole, gain)``, or ``(A, B, C, D)``.
        X0 : array_like, optional
            Initial state-vector.  Defaults to zero.
        T : array_like, optional
            Time points.  Computed if not given.
        N : int, optional
            The number of time points to compute (if `T` is not given).
        
        Returns
        -------
        T : 1D ndarray
            Time points.
        yout : 1D ndarray
            Impulse response of the system (except for singularities at zero).
    
    impulse2(system, X0=None, T=None, N=None, **kwargs)
        Impulse response of a single-input continuous-time linear system.
        
        The solution is generated by calling `scipy.signal.lsim2`, which uses
        the differential equation solver `scipy.integrate.odeint`.
        
        Parameters
        ----------
        system : an instance of the LTI class or a tuple describing the system.
            The following gives the number of elements in the tuple and
            the interpretation.
                2 (num, den)
                3 (zeros, poles, gain)
                4 (A, B, C, D)
        T : 1D ndarray or array-like, optional
            The time steps at which the input is defined and at which the
            output is desired.  If `T` is not given, the function will
            generate a set of time samples automatically.
        X0 : 1D ndarray or array-like, optional
            The initial condition of the state vector.  If X0 is None, the
            initial conditions are assumed to be 0.
        N : int, optional
            Number of time points to compute.  If `N` is not given, 100
            points are used.
        **kwargs :
            Additional keyword arguments are passed on the function
            `scipy.signal.lsim2`, which in turn passes them on to
            :func:`scipy.integrate.odeint`.  See the documentation for
            :func:`scipy.integrate.odeint` for information about these
            arguments.
        
        Returns
        -------
        T : 1D ndarray
            The time values for the output.
        yout : ndarray
            The output response of the system.
        
        See Also
        --------
        scipy.signal.impulse
        
        Notes
        -----
        .. versionadded:: 0.8.0
    
    invres(r, p, k, tol=0.001, rtype='avg')
        Compute b(s) and a(s) from partial fraction expansion: r,p,k
        
        If M = len(b) and N = len(a)
        
                b(s)     b[0] x**(M-1) + b[1] x**(M-2) + ... + b[M-1]
        H(s) = ------ = ----------------------------------------------
                a(s)     a[0] x**(N-1) + a[1] x**(N-2) + ... + a[N-1]
        
                 r[0]       r[1]             r[-1]
             = -------- + -------- + ... + --------- + k(s)
               (s-p[0])   (s-p[1])         (s-p[-1])
        
        If there are any repeated roots (closer than tol), then the partial
        fraction expansion has terms like
        
                r[i]      r[i+1]              r[i+n-1]
              -------- + ----------- + ... + -----------
              (s-p[i])  (s-p[i])**2          (s-p[i])**n
        
        See Also
        --------
        residue, poly, polyval, unique_roots
    
    invresz(r, p, k, tol=0.001, rtype='avg')
        Compute b(z) and a(z) from partial fraction expansion: r,p,k
        
        If M = len(b) and N = len(a)
        
                b(z)     b[0] + b[1] z**(-1) + ... + b[M-1] z**(-M+1)
        H(z) = ------ = ----------------------------------------------
                a(z)     a[0] + a[1] z**(-1) + ... + a[N-1] z**(-N+1)
        
                     r[0]                   r[-1]
             = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...
               (1-p[0]z**(-1))         (1-p[-1]z**(-1))
        
        If there are any repeated roots (closer than tol), then the partial
        fraction expansion has terms like
        
                   r[i]              r[i+1]                    r[i+n-1]
              -------------- + ------------------ + ... + ------------------
              (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n
        
        See also:  residuez, poly, polyval, unique_roots
    
    iscomplexobj(x)
        Return True if x is a complex type or an array of complex numbers.
        
        The type of the input is checked, not the value. So even if the input
        has an imaginary part equal to zero, `iscomplexobj` evaluates to True
        if the data type is complex.
        
        Parameters
        ----------
        x : any
            The input can be of any type and shape.
        
        Returns
        -------
        y : bool
            The return value, True if `x` is of a complex type.
        
        See Also
        --------
        isrealobj, iscomplex
        
        Examples
        --------
        >>> np.iscomplexobj(1)
        False
        >>> np.iscomplexobj(1+0j)
        True
        >>> np.iscomplexobj([3, 1+0j, True])
        True
    
    isscalar(num)
        Returns True if the type of `num` is a scalar type.
        
        Parameters
        ----------
        num : any
            Input argument, can be of any type and shape.
        
        Returns
        -------
        val : bool
            True if `num` is a scalar type, False if it is not.
        
        Examples
        --------
        >>> np.isscalar(3.1)
        True
        >>> np.isscalar([3.1])
        False
        >>> np.isscalar(False)
        True
    
    kaiser(M, beta, sym=True)
        Return a Kaiser window of length M with shape parameter beta.
    
    kaiserord(ripple, width)
        Design a Kaiser window to limit ripple and width of transition region.
        
        Parameters
        ----------
        ripple -- positive number specifying maximum ripple in passband (dB)
                    and minimum ripple in stopband
        width  -- width of transition region (normalized so that 1 corresponds
                    to pi radians / sample)
        
        Returns
        -------
        N, beta -- the order and beta parameter for the kaiser window.
        
                   signal.kaiser(N,beta,sym=0) returns the window as does
                   signal.get_window(beta,N)
                   signal.get_window(('kaiser',beta),N)
        
        Uses the empirical equations discovered by Kaiser.
        
        Oppenheim, Schafer, "Discrete-Time Signal Processing,", p.475-476.
    
    kratio(m, k_ratio)
    
    lfilter(b, a, x, axis=-1, zi=None)
        Filter data along one-dimension with an IIR or FIR filter.
        
        Filter a data sequence, x, using a digital filter.  This works for many
        fundamental data types (including Object type).  The filter is a direct
        form II transposed implementation of the standard difference equation
        (see Notes).
        
        Parameters
        ----------
        b : array_like
            The numerator coefficient vector in a 1-D sequence.
        a : array_like
            The denominator coefficient vector in a 1-D sequence.  If a[0]
            is not 1, then both a and b are normalized by a[0].
        x : array_like
            An N-dimensional input array.
        axis : int
            The axis of the input data array along which to apply the
            linear filter. The filter is applied to each subarray along
            this axis (*Default* = -1)
        zi : array_like (optional)
            Initial conditions for the filter delays.  It is a vector
            (or array of vectors for an N-dimensional input) of length
            max(len(a),len(b))-1.  If zi=None or is not given then initial
            rest is assumed.  SEE signal.lfiltic for more information.
        
        Returns
        -------
        y : array
            The output of the digital filter.
        zf : array (optional)
            If zi is None, this is not returned, otherwise, zf holds the
            final filter delay values.
        
        Notes
        -----
        The filter function is implemented as a direct II transposed structure.
        This means that the filter implements
        
        ::
        
           a[0]*y[n] = b[0]*x[n] + b[1]*x[n-1] + ... + b[nb]*x[n-nb]
                                   - a[1]*y[n-1] - ... - a[na]*y[n-na]
        
        using the following difference equations::
        
             y[m] = b[0]*x[m] + z[0,m-1]
             z[0,m] = b[1]*x[m] + z[1,m-1] - a[1]*y[m]
             ...
             z[n-3,m] = b[n-2]*x[m] + z[n-2,m-1] - a[n-2]*y[m]
             z[n-2,m] = b[n-1]*x[m] - a[n-1]*y[m]
        
        where m is the output sample number and n=max(len(a),len(b)) is the
        model order.
        
        The rational transfer function describing this filter in the
        z-transform domain is::
        
                                 -1               -nb
                     b[0] + b[1]z  + ... + b[nb] z
             Y(z) = ---------------------------------- X(z)
                                 -1               -na
                     a[0] + a[1]z  + ... + a[na] z
    
    lfilter_zi(b, a)
    
    lfiltic(b, a, y, x=None)
        Construct initial conditions for lfilter
        
        Given a linear filter (b,a) and initial conditions on the output y
        and the input x, return the inital conditions on the state vector zi
        which is used by lfilter to generate the output given the input.
        
        If M=len(b)-1 and N=len(a)-1.  Then, the initial conditions are given
        in the vectors x and y as::
        
         x = {x[-1],x[-2],...,x[-M]}
         y = {y[-1],y[-2],...,y[-N]}
        
        If x is not given, its inital conditions are assumed zero.
        If either vector is too short, then zeros are added
        to achieve the proper length.
        
        The output vector zi contains::
        
         zi = {z_0[-1], z_1[-1], ..., z_K-1[-1]}  where K=max(M,N).
    
    linspace(start, stop, num=50, endpoint=True, retstep=False)
        Return evenly spaced numbers over a specified interval.
        
        Returns `num` evenly spaced samples, calculated over the
        interval [`start`, `stop` ].
        
        The endpoint of the interval can optionally be excluded.
        
        Parameters
        ----------
        start : scalar
            The starting value of the sequence.
        stop : scalar
            The end value of the sequence, unless `endpoint` is set to False.
            In that case, the sequence consists of all but the last of ``num + 1``
            evenly spaced samples, so that `stop` is excluded.  Note that the step
            size changes when `endpoint` is False.
        num : int, optional
            Number of samples to generate. Default is 50.
        endpoint : bool, optional
            If True, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        retstep : bool, optional
            If True, return (`samples`, `step`), where `step` is the spacing
            between samples.
        
        Returns
        -------
        samples : ndarray
            There are `num` equally spaced samples in the closed interval
            ``[start, stop]`` or the half-open interval ``[start, stop)``
            (depending on whether `endpoint` is True or False).
        step : float (only if `retstep` is True)
            Size of spacing between samples.
        
        
        See Also
        --------
        arange : Similiar to `linspace`, but uses a step size (instead of the
                 number of samples).
        logspace : Samples uniformly distributed in log space.
        
        Examples
        --------
        >>> np.linspace(2.0, 3.0, num=5)
            array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ])
        >>> np.linspace(2.0, 3.0, num=5, endpoint=False)
            array([ 2. ,  2.2,  2.4,  2.6,  2.8])
        >>> np.linspace(2.0, 3.0, num=5, retstep=True)
            (array([ 2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
        
        Graphical illustration:
        
        >>> import matplotlib.pyplot as plt
        >>> N = 8
        >>> y = np.zeros(N)
        >>> x1 = np.linspace(0, 10, N, endpoint=True)
        >>> x2 = np.linspace(0, 10, N, endpoint=False)
        >>> plt.plot(x1, y, 'o')
        [<matplotlib.lines.Line2D object at 0x...>]
        >>> plt.plot(x2, y + 0.5, 'o')
        [<matplotlib.lines.Line2D object at 0x...>]
        >>> plt.ylim([-0.5, 1])
        (-0.5, 1)
        >>> plt.show()
    
    logspace(start, stop, num=50, endpoint=True, base=10.0)
        Return numbers spaced evenly on a log scale.
        
        In linear space, the sequence starts at ``base ** start``
        (`base` to the power of `start`) and ends with ``base ** stop``
        (see `endpoint` below).
        
        Parameters
        ----------
        start : float
            ``base ** start`` is the starting value of the sequence.
        stop : float
            ``base ** stop`` is the final value of the sequence, unless `endpoint`
            is False.  In that case, ``num + 1`` values are spaced over the
            interval in log-space, of which all but the last (a sequence of
            length ``num``) are returned.
        num : integer, optional
            Number of samples to generate.  Default is 50.
        endpoint : boolean, optional
            If true, `stop` is the last sample. Otherwise, it is not included.
            Default is True.
        base : float, optional
            The base of the log space. The step size between the elements in
            ``ln(samples) / ln(base)`` (or ``log_base(samples)``) is uniform.
            Default is 10.0.
        
        Returns
        -------
        samples : ndarray
            `num` samples, equally spaced on a log scale.
        
        See Also
        --------
        arange : Similiar to linspace, with the step size specified instead of the
                 number of samples. Note that, when used with a float endpoint, the
                 endpoint may or may not be included.
        linspace : Similar to logspace, but with the samples uniformly distributed
                   in linear space, instead of log space.
        
        Notes
        -----
        Logspace is equivalent to the code
        
        >>> y = np.linspace(start, stop, num=num, endpoint=endpoint)
        ... # doctest: +SKIP
        >>> power(base, y)
        ... # doctest: +SKIP
        
        Examples
        --------
        >>> np.logspace(2.0, 3.0, num=4)
            array([  100.        ,   215.443469  ,   464.15888336,  1000.        ])
        >>> np.logspace(2.0, 3.0, num=4, endpoint=False)
            array([ 100.        ,  177.827941  ,  316.22776602,  562.34132519])
        >>> np.logspace(2.0, 3.0, num=4, base=2.0)
            array([ 4.        ,  5.0396842 ,  6.34960421,  8.        ])
        
        Graphical illustration:
        
        >>> import matplotlib.pyplot as plt
        >>> N = 10
        >>> x1 = np.logspace(0.1, 1, N, endpoint=True)
        >>> x2 = np.logspace(0.1, 1, N, endpoint=False)
        >>> y = np.zeros(N)
        >>> plt.plot(x1, y, 'o')
        [<matplotlib.lines.Line2D object at 0x...>]
        >>> plt.plot(x2, y + 0.5, 'o')
        [<matplotlib.lines.Line2D object at 0x...>]
        >>> plt.ylim([-0.5, 1])
        (-0.5, 1)
        >>> plt.show()
    
    lp2bp(b, a, wo=1.0, bw=1.0)
        Return a band-pass filter with center frequency wo and bandwidth bw
        from a low-pass filter prototype with unity cutoff frequency.
    
    lp2bs(b, a, wo=1, bw=1)
        Return a band-stop filter with center frequency wo and bandwidth bw
        from a low-pass filter prototype with unity cutoff frequency.
    
    lp2hp(b, a, wo=1.0)
        Return a high-pass filter with cuttoff frequency wo
        from a low-pass filter prototype with unity cutoff frequency.
    
    lp2lp(b, a, wo=1.0)
        Return a low-pass filter with cuttoff frequency wo
        from a low-pass filter prototype with unity cutoff frequency.
    
    lsim(system, U, T, X0=None, interp=1)
        Simulate output of a continuous-time linear system.
        
        Parameters
        ----------
        system : an instance of the LTI class or a tuple describing the system.
            The following gives the number of elements in the tuple and
            the interpretation:
        
            * 2: (num, den)
            * 3: (zeros, poles, gain)
            * 4: (A, B, C, D)
        
        U : array_like
            An input array describing the input at each time `T`
            (interpolation is assumed between given times).  If there are
            multiple inputs, then each column of the rank-2 array
            represents an input.
        T : array_like
            The time steps at which the input is defined and at which the
            output is desired.
        X0 :
            The initial conditions on the state vector (zero by default).
        interp : {1, 0}
            Whether to use linear (1) or zero-order hold (0) interpolation.
        
        Returns
        -------
        T : 1D ndarray
            Time values for the output.
        yout : 1D ndarray
            System response.
        xout : ndarray
            Time-evolution of the state-vector.
    
    lsim2(system, U=None, T=None, X0=None, **kwargs)
        Simulate output of a continuous-time linear system, by using
        the ODE solver `scipy.integrate.odeint`.
        
        Parameters
        ----------
        system : an instance of the LTI class or a tuple describing the system.
            The following gives the number of elements in the tuple and
            the interpretation:
        
            * 2: (num, den)
            * 3: (zeros, poles, gain)
            * 4: (A, B, C, D)
        
        U : ndarray or array-like (1D or 2D), optional
            An input array describing the input at each time T.  Linear
            interpolation is used between given times.  If there are
            multiple inputs, then each column of the rank-2 array
            represents an input.  If U is not given, the input is assumed
            to be zero.
        T : ndarray or array-like (1D or 2D), optional
            The time steps at which the input is defined and at which the
            output is desired.  The default is 101 evenly spaced points on
            the interval [0,10.0].
        X0 : ndarray or array-like (1D), optional
            The initial condition of the state vector.  If `X0` is not
            given, the initial conditions are assumed to be 0.
        kwargs : dict
            Additional keyword arguments are passed on to the function
            odeint.  See the notes below for more details.
        
        Returns
        -------
        T : 1D ndarray
            The time values for the output.
        yout : ndarray
            The response of the system.
        xout : ndarray
            The time-evolution of the state-vector.
        
        Notes
        -----
        This function uses :func:`scipy.integrate.odeint` to solve the
        system's differential equations.  Additional keyword arguments
        given to `lsim2` are passed on to `odeint`.  See the documentation
        for :func:`scipy.integrate.odeint` for the full list of arguments.
    
    maxflat()
    
    mean(a, axis=None, dtype=None, out=None)
        Compute the arithmetic mean along the specified axis.
        
        Returns the average of the array elements.  The average is taken over
        the flattened array by default, otherwise over the specified axis.
        `float64` intermediate and return values are used for integer inputs.
        
        Parameters
        ----------
        a : array_like
            Array containing numbers whose mean is desired. If `a` is not an
            array, a conversion is attempted.
        axis : int, optional
            Axis along which the means are computed. The default is to compute
            the mean of the flattened array.
        dtype : data-type, optional
            Type to use in computing the mean.  For integer inputs, the default
            is `float64`; for floating point inputs, it is the same as the
            input dtype.
        out : ndarray, optional
            Alternate output array in which to place the result.  The default
            is ``None``; if provided, it must have the same shape as the
            expected output, but the type will be cast if necessary.
            See `doc.ufuncs` for details.
        
        Returns
        -------
        m : ndarray, see dtype parameter above
            If `out=None`, returns a new array containing the mean values,
            otherwise a reference to the output array is returned.
        
        See Also
        --------
        average : Weighted average
        
        Notes
        -----
        The arithmetic mean is the sum of the elements along the axis divided
        by the number of elements.
        
        Note that for floating-point input, the mean is computed using the
        same precision the input has.  Depending on the input data, this can
        cause the results to be inaccurate, especially for `float32` (see
        example below).  Specifying a higher-precision accumulator using the
        `dtype` keyword can alleviate this issue.
        
        Examples
        --------
        >>> a = np.array([[1, 2], [3, 4]])
        >>> np.mean(a)
        2.5
        >>> np.mean(a, axis=0)
        array([ 2.,  3.])
        >>> np.mean(a, axis=1)
        array([ 1.5,  3.5])
        
        In single precision, `mean` can be inaccurate:
        
        >>> a = np.zeros((2, 512*512), dtype=np.float32)
        >>> a[0, :] = 1.0
        >>> a[1, :] = 0.1
        >>> np.mean(a)
        0.546875
        
        Computing the mean in float64 is more accurate:
        
        >>> np.mean(a, dtype=np.float64)
        0.55000000074505806
    
    medfilt(volume, kernel_size=None)
        Perform a median filter on an N-dimensional array.
        
        Description:
        
          Apply a median filter to the input array using a local window-size
          given by kernel_size.
        
        Inputs:
        
          in -- An N-dimensional input array.
          kernel_size -- A scalar or an N-length list giving the size of the
                         median filter window in each dimension.  Elements of
                         kernel_size should be odd.  If kernel_size is a scalar,
                         then this scalar is used as the size in each dimension.
        
        Outputs: (out,)
        
          out -- An array the same size as input containing the median filtered
                 result.
    
    medfilt2d(input, kernel_size=3)
        Median filter two 2-dimensional arrays.
        
        Description:
        
          Apply a median filter to the input array using a local window-size
          given by kernel_size (must be odd).
        
        Inputs:
        
          in -- An 2 dimensional input array.
          kernel_size -- A scalar or an length-2 list giving the size of the
                         median filter window in each dimension.  Elements of
                         kernel_size should be odd.  If kernel_size is a scalar,
                         then this scalar is used as the size in each dimension.
        
        Outputs: (out,)
        
          out -- An array the same size as input containing the median filtered
                 result.
    
    mintypecode(typechars, typeset='GDFgdf', default='d')
        Return the character for the minimum-size type to which given types can
        be safely cast.
        
        The returned type character must represent the smallest size dtype such
        that an array of the returned type can handle the data from an array of
        all types in `typechars` (or if `typechars` is an array, then its
        dtype.char).
        
        Parameters
        ----------
        typechars : list of str or array_like
            If a list of strings, each string should represent a dtype.
            If array_like, the character representation of the array dtype is used.
        typeset : str or list of str, optional
            The set of characters that the returned character is chosen from.
            The default set is 'GDFgdf'.
        default : str, optional
            The default character, this is returned if none of the characters in
            `typechars` matches a character in `typeset`.
        
        Returns
        -------
        typechar : str
            The character representing the minimum-size type that was found.
        
        See Also
        --------
        dtype, sctype2char, maximum_sctype
        
        Examples
        --------
        >>> np.mintypecode(['d', 'f', 'S'])
        'd'
        >>> x = np.array([1.1, 2-3.j])
        >>> np.mintypecode(x)
        'D'
        
        >>> np.mintypecode('abceh', default='G')
        'G'
    
    morlet(M, w=5.0, s=1.0, complete=True)
        Complex Morlet wavelet.
        
        Parameters
        ----------
        M : int
            Length of the wavelet.
        w : float
            Omega0
        s : float
            Scaling factor, windowed from -s*2*pi to +s*2*pi.
        complete : bool
            Whether to use the complete or the standard version.
        
        Notes
        -----
        The standard version:
            pi**-0.25 * exp(1j*w*x) * exp(-0.5*(x**2))
        
            This commonly used wavelet is often referred to simply as the
            Morlet wavelet.  Note that, this simplified version can cause
            admissibility problems at low values of w.
        
        The complete version:
            pi**-0.25 * (exp(1j*w*x) - exp(-0.5*(w**2))) * exp(-0.5*(x**2))
        
            The complete version of the Morlet wavelet, with a correction
            term to improve admissibility. For w greater than 5, the
            correction term is negligible.
        
        Note that the energy of the return wavelet is not normalised
        according to s.
        
        The fundamental frequency of this wavelet in Hz is given
        by f = 2*s*w*r / M where r is the sampling rate.
    
    nan_to_num(x)
        Replace nan with zero and inf with finite numbers.
        
        Returns an array or scalar replacing Not a Number (NaN) with zero,
        (positive) infinity with a very large number and negative infinity
        with a very small (or negative) number.
        
        Parameters
        ----------
        x : array_like
            Input data.
        
        Returns
        -------
        out : ndarray, float
            Array with the same shape as `x` and dtype of the element in `x`  with
            the greatest precision. NaN is replaced by zero, and infinity
            (-infinity) is replaced by the largest (smallest or most negative)
            floating point value that fits in the output dtype. All finite numbers
            are upcast to the output dtype (default float64).
        
        See Also
        --------
        isinf : Shows which elements are negative or negative infinity.
        isneginf : Shows which elements are negative infinity.
        isposinf : Shows which elements are positive infinity.
        isnan : Shows which elements are Not a Number (NaN).
        isfinite : Shows which elements are finite (not NaN, not infinity)
        
        Notes
        -----
        Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic
        (IEEE 754). This means that Not a Number is not equivalent to infinity.
        
        
        Examples
        --------
        >>> np.set_printoptions(precision=8)
        >>> x = np.array([np.inf, -np.inf, np.nan, -128, 128])
        >>> np.nan_to_num(x)
        array([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000,
                -1.28000000e+002,   1.28000000e+002])
    
    normalize(b, a)
        Normalize polynomial representation of a transfer function.
        
        If values of b are too close to 0, they are removed. In that case, a
        BadCoefficients warning is emitted.
    
    nuttall(M, sym=True)
        A minimum 4-term Blackman-Harris window according to Nuttall.
    
    old_chirp(t, f0=0, t1=1, f1=100, method='linear', phi=0, qshape=None)
        Frequency-swept cosine generator.
        
        Parameters
        ----------
        t : ndarray
            Times at which to evaluate the waveform.
        f0 : float or ndarray, optional
            Frequency (in Hz) of the waveform at time 0.  If `f0` is an
            ndarray, it specifies the frequency change as a polynomial in
            `t` (see Notes below).
        t1 : float, optional
            Time at which `f1` is specified.
        f1 : float, optional
            Frequency (in Hz) of the waveform at time `t1`.
        method : {'linear', 'quadratic', 'logarithmic'}, optional
            Kind of frequency sweep.
        phi : float
            Phase offset, in degrees.
        qshape : {'convex', 'concave'}
            If method is 'quadratic', `qshape` specifies its shape.
        
        Notes
        -----
        If `f0` is an array, it forms the coefficients of a polynomial in
        `t` (see `numpy.polval`). The polynomial determines the waveform
        frequency change in time.  In this case, the values of `f1`, `t1`,
        `method`, and `qshape` are ignored.
        
        This function is deprecated.  It will be removed in SciPy version 0.9.0.
        It exists so that during in version 0.8.0, the new chirp function can
        call this function to preserve the old behavior of the quadratic chirp.
    
    ones(shape, dtype=None, order='C')
        Return a new array of given shape and type, filled with ones.
        
        Please refer to the documentation for `zeros` for further details.
        
        See Also
        --------
        zeros, ones_like
        
        Examples
        --------
        >>> np.ones(5)
        array([ 1.,  1.,  1.,  1.,  1.])
        
        >>> np.ones((5,), dtype=np.int)
        array([1, 1, 1, 1, 1])
        
        >>> np.ones((2, 1))
        array([[ 1.],
               [ 1.]])
        
        >>> s = (2,2)
        >>> np.ones(s)
        array([[ 1.,  1.],
               [ 1.,  1.]])
    
    order_filter(a, domain, rank)
        Perform an order filter on an N-dimensional array.
        
        Description:
        
          Perform an order filter on the array in.  The domain argument acts as a
          mask centered over each pixel.  The non-zero elements of domain are
          used to select elements surrounding each input pixel which are placed
          in a list.   The list is sorted, and the output for that pixel is the
          element corresponding to rank in the sorted list.
        
        Parameters
        ----------
          in -- an N-dimensional input array.
          domain -- a mask array with the same number of dimensions as in.  Each
                    dimension should have an odd number of elements.
          rank -- an non-negative integer which selects the element from the
                  sorted list (0 corresponds to the largest element, 1 is the
                  next largest element, etc.)
        
        Returns
        -------
          out -- the results of the order filter in an array with the same
                 shape as in.
    
    parzen(M, sym=True)
        The M-point Parzen window.
    
    piecewise(x, condlist, funclist, *args, **kw)
        Evaluate a piecewise-defined function.
        
        Given a set of conditions and corresponding functions, evaluate each
        function on the input data wherever its condition is true.
        
        Parameters
        ----------
        x : ndarray
            The input domain.
        condlist : list of bool arrays
            Each boolean array corresponds to a function in `funclist`.  Wherever
            `condlist[i]` is True, `funclist[i](x)` is used as the output value.
        
            Each boolean array in `condlist` selects a piece of `x`,
            and should therefore be of the same shape as `x`.
        
            The length of `condlist` must correspond to that of `funclist`.
            If one extra function is given, i.e. if
            ``len(funclist) - len(condlist) == 1``, then that extra function
            is the default value, used wherever all conditions are false.
        funclist : list of callables, f(x,*args,**kw), or scalars
            Each function is evaluated over `x` wherever its corresponding
            condition is True.  It should take an array as input and give an array
            or a scalar value as output.  If, instead of a callable,
            a scalar is provided then a constant function (``lambda x: scalar``) is
            assumed.
        args : tuple, optional
            Any further arguments given to `piecewise` are passed to the functions
            upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then
            each function is called as ``f(x, 1, 'a')``.
        kw : dict, optional
            Keyword arguments used in calling `piecewise` are passed to the
            functions upon execution, i.e., if called
            ``piecewise(..., ..., lambda=1)``, then each function is called as
            ``f(x, lambda=1)``.
        
        Returns
        -------
        out : ndarray
            The output is the same shape and type as x and is found by
            calling the functions in `funclist` on the appropriate portions of `x`,
            as defined by the boolean arrays in `condlist`.  Portions not covered
            by any condition have undefined values.
        
        
        See Also
        --------
        choose, select, where
        
        Notes
        -----
        This is similar to choose or select, except that functions are
        evaluated on elements of `x` that satisfy the corresponding condition from
        `condlist`.
        
        The result is::
        
                |--
                |funclist[0](x[condlist[0]])
          out = |funclist[1](x[condlist[1]])
                |...
                |funclist[n2](x[condlist[n2]])
                |--
        
        Examples
        --------
        Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.
        
        >>> x = np.arange(6) - 2.5
        >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])
        array([-1., -1., -1.,  1.,  1.,  1.])
        
        Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for
        ``x >= 0``.
        
        >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])
        array([ 2.5,  1.5,  0.5,  0.5,  1.5,  2.5])
    
    place(arr, mask, vals)
        Change elements of an array based on conditional and input values.
        
        Similar to ``np.putmask(arr, mask, vals)``, the difference is that `place`
        uses the first N elements of `vals`, where N is the number of True values
        in `mask`, while `putmask` uses the elements where `mask` is True.
        
        Note that `extract` does the exact opposite of `place`.
        
        Parameters
        ----------
        arr : array_like
            Array to put data into.
        mask : array_like
            Boolean mask array. Must have the same size as `a`.
        vals : 1-D sequence
            Values to put into `a`. Only the first N elements are used, where
            N is the number of True values in `mask`. If `vals` is smaller
            than N it will be repeated.
        
        See Also
        --------
        putmask, put, take, extract
        
        Examples
        --------
        >>> arr = np.arange(6).reshape(2, 3)
        >>> np.place(arr, arr>2, [44, 55])
        >>> arr
        array([[ 0,  1,  2],
               [44, 55, 44]])
    
    poly(seq_of_zeros)
        Find the coefficients of a polynomial with the given sequence of roots.
        
        Returns the coefficients of the polynomial whose leading coefficient
        is one for the given sequence of zeros (multiple roots must be included
        in the sequence as many times as their multiplicity; see Examples).
        A square matrix (or array, which will be treated as a matrix) can also
        be given, in which case the coefficients of the characteristic polynomial
        of the matrix are returned.
        
        Parameters
        ----------
        seq_of_zeros : array_like, shape (N,) or (N, N)
            A sequence of polynomial roots, or a square array or matrix object.
        
        Returns
        -------
        c : ndarray
            1D array of polynomial coefficients from highest to lowest degree:
        
            ``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``
            where c[0] always equals 1.
        
        Raises
        ------
        ValueError
            If input is the wrong shape (the input must be a 1-D or square
            2-D array).
        
        See Also
        --------
        polyval : Evaluate a polynomial at a point.
        roots : Return the roots of a polynomial.
        polyfit : Least squares polynomial fit.
        poly1d : A one-dimensional polynomial class.
        
        Notes
        -----
        Specifying the roots of a polynomial still leaves one degree of
        freedom, typically represented by an undetermined leading
        coefficient. [1]_ In the case of this function, that coefficient -
        the first one in the returned array - is always taken as one. (If
        for some reason you have one other point, the only automatic way
        presently to leverage that information is to use ``polyfit``.)
        
        The characteristic polynomial, :math:`p_a(t)`, of an `n`-by-`n`
        matrix **A** is given by
        
            :math:`p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})`,
        
        where **I** is the `n`-by-`n` identity matrix. [2]_
        
        References
        ----------
        .. [1] M. Sullivan and M. Sullivan, III, "Algebra and Trignometry,
           Enhanced With Graphing Utilities," Prentice-Hall, pg. 318, 1996.
        
        .. [2] G. Strang, "Linear Algebra and Its Applications, 2nd Edition,"
           Academic Press, pg. 182, 1980.
        
        Examples
        --------
        Given a sequence of a polynomial's zeros:
        
        >>> np.poly((0, 0, 0)) # Multiple root example
        array([1, 0, 0, 0])
        
        The line above represents z**3 + 0*z**2 + 0*z + 0.
        
        >>> np.poly((-1./2, 0, 1./2))
        array([ 1.  ,  0.  , -0.25,  0.  ])
        
        The line above represents z**3 - z/4
        
        >>> np.poly((np.random.random(1.)[0], 0, np.random.random(1.)[0]))
        array([ 1.        , -0.77086955,  0.08618131,  0.        ]) #random
        
        Given a square array object:
        
        >>> P = np.array([[0, 1./3], [-1./2, 0]])
        >>> np.poly(P)
        array([ 1.        ,  0.        ,  0.16666667])
        
        Or a square matrix object:
        
        >>> np.poly(np.matrix(P))
        array([ 1.        ,  0.        ,  0.16666667])
        
        Note how in all cases the leading coefficient is always 1.
    
    polyadd(a1, a2)
        Find the sum of two polynomials.
        
        Returns the polynomial resulting from the sum of two input polynomials.
        Each input must be either a poly1d object or a 1D sequence of polynomial
        coefficients, from highest to lowest degree.
        
        Parameters
        ----------
        a1, a2 : array_like or poly1d object
            Input polynomials.
        
        Returns
        -------
        out : ndarray or poly1d object
            The sum of the inputs. If either input is a poly1d object, then the
            output is also a poly1d object. Otherwise, it is a 1D array of
            polynomial coefficients from highest to lowest degree.
        
        See Also
        --------
        poly1d : A one-dimensional polynomial class.
        poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval
        
        Examples
        --------
        >>> np.polyadd([1, 2], [9, 5, 4])
        array([9, 6, 6])
        
        Using poly1d objects:
        
        >>> p1 = np.poly1d([1, 2])
        >>> p2 = np.poly1d([9, 5, 4])
        >>> print p1
        1 x + 2
        >>> print p2
           2
        9 x + 5 x + 4
        >>> print np.polyadd(p1, p2)
           2
        9 x + 6 x + 6
    
    polyder(p, m=1)
        Return the derivative of the specified order of a polynomial.
        
        Parameters
        ----------
        p : poly1d or sequence
            Polynomial to differentiate.
            A sequence is interpreted as polynomial coefficients, see `poly1d`.
        m : int, optional
            Order of differentiation (default: 1)
        
        Returns
        -------
        der : poly1d
            A new polynomial representing the derivative.
        
        See Also
        --------
        polyint : Anti-derivative of a polynomial.
        poly1d : Class for one-dimensional polynomials.
        
        Examples
        --------
        The derivative of the polynomial :math:`x^3 + x^2 + x^1 + 1` is:
        
        >>> p = np.poly1d([1,1,1,1])
        >>> p2 = np.polyder(p)
        >>> p2
        poly1d([3, 2, 1])
        
        which evaluates to:
        
        >>> p2(2.)
        17.0
        
        We can verify this, approximating the derivative with
        ``(f(x + h) - f(x))/h``:
        
        >>> (p(2. + 0.001) - p(2.)) / 0.001
        17.007000999997857
        
        The fourth-order derivative of a 3rd-order polynomial is zero:
        
        >>> np.polyder(p, 2)
        poly1d([6, 2])
        >>> np.polyder(p, 3)
        poly1d([6])
        >>> np.polyder(p, 4)
        poly1d([ 0.])
    
    polydiv(u, v)
        Returns the quotient and remainder of polynomial division.
        
        The input arrays are the coefficients (including any coefficients
        equal to zero) of the "numerator" (dividend) and "denominator"
        (divisor) polynomials, respectively.
        
        Parameters
        ----------
        u : array_like or poly1d
            Dividend polynomial's coefficients.
        
        v : array_like or poly1d
            Divisor polynomial's coefficients.
        
        Returns
        -------
        q : ndarray
            Coefficients, including those equal to zero, of the quotient.
        r : ndarray
            Coefficients, including those equal to zero, of the remainder.
        
        See Also
        --------
        poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub,
        polyval
        
        Notes
        -----
        Both `u` and `v` must be 0-d or 1-d (ndim = 0 or 1), but `u.ndim` need
        not equal `v.ndim`. In other words, all four possible combinations -
        ``u.ndim = v.ndim = 0``, ``u.ndim = v.ndim = 1``,
        ``u.ndim = 1, v.ndim = 0``, and ``u.ndim = 0, v.ndim = 1`` - work.
        
        Examples
        --------
        .. math:: \frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25
        
        >>> x = np.array([3.0, 5.0, 2.0])
        >>> y = np.array([2.0, 1.0])
        >>> np.polydiv(x, y)
        (array([ 1.5 ,  1.75]), array([ 0.25]))
    
    polyint(p, m=1, k=None)
        Return an antiderivative (indefinite integral) of a polynomial.
        
        The returned order `m` antiderivative `P` of polynomial `p` satisfies
        :math:`\frac{d^m}{dx^m}P(x) = p(x)` and is defined up to `m - 1`
        integration constants `k`. The constants determine the low-order
        polynomial part
        
        .. math:: \frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}
        
        of `P` so that :math:`P^{(j)}(0) = k_{m-j-1}`.
        
        Parameters
        ----------
        p : {array_like, poly1d}
            Polynomial to differentiate.
            A sequence is interpreted as polynomial coefficients, see `poly1d`.
        m : int, optional
            Order of the antiderivative. (Default: 1)
        k : {None, list of `m` scalars, scalar}, optional
            Integration constants. They are given in the order of integration:
            those corresponding to highest-order terms come first.
        
            If ``None`` (default), all constants are assumed to be zero.
            If `m = 1`, a single scalar can be given instead of a list.
        
        See Also
        --------
        polyder : derivative of a polynomial
        poly1d.integ : equivalent method
        
        Examples
        --------
        The defining property of the antiderivative:
        
        >>> p = np.poly1d([1,1,1])
        >>> P = np.polyint(p)
        >>> P
        poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ])
        >>> np.polyder(P) == p
        True
        
        The integration constants default to zero, but can be specified:
        
        >>> P = np.polyint(p, 3)
        >>> P(0)
        0.0
        >>> np.polyder(P)(0)
        0.0
        >>> np.polyder(P, 2)(0)
        0.0
        >>> P = np.polyint(p, 3, k=[6,5,3])
        >>> P
        poly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ])
        
        Note that 3 = 6 / 2!, and that the constants are given in the order of
        integrations. Constant of the highest-order polynomial term comes first:
        
        >>> np.polyder(P, 2)(0)
        6.0
        >>> np.polyder(P, 1)(0)
        5.0
        >>> P(0)
        3.0
    
    polymul(a1, a2)
        Find the product of two polynomials.
        
        Finds the polynomial resulting from the multiplication of the two input
        polynomials. Each input must be either a poly1d object or a 1D sequence
        of polynomial coefficients, from highest to lowest degree.
        
        Parameters
        ----------
        a1, a2 : array_like or poly1d object
            Input polynomials.
        
        Returns
        -------
        out : ndarray or poly1d object
            The polynomial resulting from the multiplication of the inputs. If
            either inputs is a poly1d object, then the output is also a poly1d
            object. Otherwise, it is a 1D array of polynomial coefficients from
            highest to lowest degree.
        
        See Also
        --------
        poly1d : A one-dimensional polynomial class.
        poly, polyadd, polyder, polydiv, polyfit, polyint, polysub,
        polyval
        
        Examples
        --------
        >>> np.polymul([1, 2, 3], [9, 5, 1])
        array([ 9, 23, 38, 17,  3])
        
        Using poly1d objects:
        
        >>> p1 = np.poly1d([1, 2, 3])
        >>> p2 = np.poly1d([9, 5, 1])
        >>> print p1
           2
        1 x + 2 x + 3
        >>> print p2
           2
        9 x + 5 x + 1
        >>> print np.polymul(p1, p2)
           4      3      2
        9 x + 23 x + 38 x + 17 x + 3
    
    polysub(a1, a2)
        Difference (subtraction) of two polynomials.
        
        Given two polynomials `a1` and `a2`, returns ``a1 - a2``.
        `a1` and `a2` can be either array_like sequences of the polynomials'
        coefficients (including coefficients equal to zero), or `poly1d` objects.
        
        Parameters
        ----------
        a1, a2 : array_like or poly1d
            Minuend and subtrahend polynomials, respectively.
        
        Returns
        -------
        out : ndarray or poly1d
            Array or `poly1d` object of the difference polynomial's coefficients.
        
        See Also
        --------
        polyval, polydiv, polymul, polyadd
        
        Examples
        --------
        .. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)
        
        >>> np.polysub([2, 10, -2], [3, 10, -4])
        array([-1,  0,  2])
    
    polyval(p, x)
        Evaluate a polynomial at specific values.
        
        If `p` is of length N, this function returns the value:
        
            ``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``
        
        If `x` is a sequence, then `p(x)` is returned for each element of `x`.
        If `x` is another polynomial then the composite polynomial `p(x(t))`
        is returned.
        
        Parameters
        ----------
        p : array_like or poly1d object
           1D array of polynomial coefficients (including coefficients equal
           to zero) from highest degree to the constant term, or an
           instance of poly1d.
        x : array_like or poly1d object
           A number, a 1D array of numbers, or an instance of poly1d, "at"
           which to evaluate `p`.
        
        Returns
        -------
        values : ndarray or poly1d
           If `x` is a poly1d instance, the result is the composition of the two
           polynomials, i.e., `x` is "substituted" in `p` and the simplified
           result is returned. In addition, the type of `x` - array_like or
           poly1d - governs the type of the output: `x` array_like => `values`
           array_like, `x` a poly1d object => `values` is also.
        
        See Also
        --------
        poly1d: A polynomial class.
        
        Notes
        -----
        Horner's scheme [1]_ is used to evaluate the polynomial. Even so,
        for polynomials of high degree the values may be inaccurate due to
        rounding errors. Use carefully.
        
        References
        ----------
        .. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.
           trans. Ed.), *Handbook of Mathematics*, New York, Van Nostrand
           Reinhold Co., 1985, pg. 720.
        
        Examples
        --------
        >>> np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1
        76
        >>> np.polyval([3,0,1], np.poly1d(5))
        poly1d([ 76.])
        >>> np.polyval(np.poly1d([3,0,1]), 5)
        76
        >>> np.polyval(np.poly1d([3,0,1]), np.poly1d(5))
        poly1d([ 76.])
    
    prod(a, axis=None, dtype=None, out=None)
        Return the product of array elements over a given axis.
        
        Parameters
        ----------
        a : array_like
            Input data.
        axis : int, optional
            Axis over which the product is taken.  By default, the product
            of all elements is calculated.
        dtype : data-type, optional
            The data-type of the returned array, as well as of the accumulator
            in which the elements are multiplied.  By default, if `a` is of
            integer type, `dtype` is the default platform integer. (Note: if
            the type of `a` is unsigned, then so is `dtype`.)  Otherwise,
            the dtype is the same as that of `a`.
        out : ndarray, optional
            Alternative output array in which to place the result. It must have
            the same shape as the expected output, but the type of the
            output values will be cast if necessary.
        
        Returns
        -------
        product_along_axis : ndarray, see `dtype` parameter above.
            An array shaped as `a` but with the specified axis removed.
            Returns a reference to `out` if specified.
        
        See Also
        --------
        ndarray.prod : equivalent method
        numpy.doc.ufuncs : Section "Output arguments"
        
        Notes
        -----
        Arithmetic is modular when using integer types, and no error is
        raised on overflow.  That means that, on a 32-bit platform:
        
        >>> x = np.array([536870910, 536870910, 536870910, 536870910])
        >>> np.prod(x) #random
        16
        
        Examples
        --------
        By default, calculate the product of all elements:
        
        >>> np.prod([1.,2.])
        2.0
        
        Even when the input array is two-dimensional:
        
        >>> np.prod([[1.,2.],[3.,4.]])
        24.0
        
        But we can also specify the axis over which to multiply:
        
        >>> np.prod([[1.,2.],[3.,4.]], axis=1)
        array([  2.,  12.])
        
        If the type of `x` is unsigned, then the output type is
        the unsigned platform integer:
        
        >>> x = np.array([1, 2, 3], dtype=np.uint8)
        >>> np.prod(x).dtype == np.uint
        True
        
        If `x` is of a signed integer type, then the output type
        is the default platform integer:
        
        >>> x = np.array([1, 2, 3], dtype=np.int8)
        >>> np.prod(x).dtype == np.int
        True
    
    product(a, axis=None, dtype=None, out=None)
        Return the product of array elements over a given axis.
        
        See Also
        --------
        prod : equivalent function; see for details.
    
    qmf(hk)
        Return high-pass qmf filter from low-pass
    
    qspline1d(signal, lamb=0.0)
        Compute quadratic spline coefficients for rank-1 array.
        
        Description:
        
          Find the quadratic spline coefficients for a 1-D signal assuming
          mirror-symmetric boundary conditions.   To obtain the signal back from
          the spline representation mirror-symmetric-convolve these coefficients
          with a length 3 FIR window [1.0, 6.0, 1.0]/ 8.0 .
        
        Inputs:
        
          signal -- a rank-1 array representing samples of a signal.
          lamb -- smoothing coefficient (must be zero for now.)
        
        Output:
        
          c -- cubic spline coefficients.
    
    qspline1d_eval(cj, newx, dx=1.0, x0=0)
        Evaluate a quadratic spline at the new set of points.
        dx is the old sample-spacing while x0 was the old origin.
        
        In other-words the old-sample points (knot-points) for which the cj
        represent spline coefficients were at equally-spaced points of
        
        oldx = x0 + j*dx  j=0...N-1
        
        N=len(cj)
        
        edges are handled using mirror-symmetric boundary conditions.
    
    qspline2d(...)
        qspline2d(input {, lambda, precision}) -> qk
        
        Description:
        
          Return the second-order B-spline coefficients over a regularly spaced
          input grid for the two-dimensional input image.  The lambda argument
          specifies the amount of smoothing.  The precision argument allows specifying
          the precision used when computing the infinite sum needed to apply mirror-
          symmetric boundary conditions.
    
    quadratic(x)
        Special case of bspline. Equivalent to bspline(x,2).
    
    rank(a)
        Return the number of dimensions of an array.
        
        If `a` is not already an array, a conversion is attempted.
        Scalars are zero dimensional.
        
        Parameters
        ----------
        a : array_like
            Array whose number of dimensions is desired. If `a` is not an array,
            a conversion is attempted.
        
        Returns
        -------
        number_of_dimensions : int
            The number of dimensions in the array.
        
        See Also
        --------
        ndim : equivalent function
        ndarray.ndim : equivalent property
        shape : dimensions of array
        ndarray.shape : dimensions of array
        
        Notes
        -----
        In the old Numeric package, `rank` was the term used for the number of
        dimensions, but in Numpy `ndim` is used instead.
        
        Examples
        --------
        >>> np.rank([1,2,3])
        1
        >>> np.rank(np.array([[1,2,3],[4,5,6]]))
        2
        >>> np.rank(1)
        0
    
    ravel(a, order='C')
        Return a flattened array.
        
        A 1-D array, containing the elements of the input, is returned.  A copy is
        made only if needed.
        
        Parameters
        ----------
        a : array_like
            Input array.  The elements in `a` are read in the order specified by
            `order`, and packed as a 1-D array.
        order : {'C','F'}, optional
            The elements of `a` are read in this order.  It can be either
            'C' for row-major order, or `F` for column-major order.
            By default, row-major order is used.
        
        Returns
        -------
        1d_array : ndarray
            Output of the same dtype as `a`, and of shape ``(a.size(),)``.
        
        See Also
        --------
        ndarray.flat : 1-D iterator over an array.
        ndarray.flatten : 1-D array copy of the elements of an array
                          in row-major order.
        
        Notes
        -----
        In row-major order, the row index varies the slowest, and the column
        index the quickest.  This can be generalized to multiple dimensions,
        where row-major order implies that the index along the first axis
        varies slowest, and the index along the last quickest.  The opposite holds
        for Fortran-, or column-major, mode.
        
        Examples
        --------
        If an array is in C-order (default), then `ravel` is equivalent
        to ``reshape(-1)``:
        
        >>> x = np.array([[1, 2, 3], [4, 5, 6]])
        >>> print x.reshape(-1)
        [1  2  3  4  5  6]
        
        >>> print np.ravel(x)
        [1  2  3  4  5  6]
        
        When flattening using Fortran-order, however, we see
        
        >>> print np.ravel(x, order='F')
        [1 4 2 5 3 6]
    
    real(val)
        Return the real part of the elements of the array.
        
        Parameters
        ----------
        val : array_like
            Input array.
        
        Returns
        -------
        out : ndarray
            Output array. If `val` is real, the type of `val` is used for the
            output.  If `val` has complex elements, the returned type is float.
        
        See Also
        --------
        real_if_close, imag, angle
        
        Examples
        --------
        >>> a = np.array([1+2j, 3+4j, 5+6j])
        >>> a.real
        array([ 1.,  3.,  5.])
        >>> a.real = 9
        >>> a
        array([ 9.+2.j,  9.+4.j,  9.+6.j])
        >>> a.real = np.array([9, 8, 7])
        >>> a
        array([ 9.+2.j,  8.+4.j,  7.+6.j])
    
    real_if_close(a, tol=100)
        If complex input returns a real array if complex parts are close to zero.
        
        "Close to zero" is defined as `tol` * (machine epsilon of the type for
        `a`).
        
        Parameters
        ----------
        a : array_like
            Input array.
        tol : float
            Tolerance in machine epsilons for the complex part of the elements
            in the array.
        
        Returns
        -------
        out : ndarray
            If `a` is real, the type of `a` is used for the output.  If `a`
            has complex elements, the returned type is float.
        
        See Also
        --------
        real, imag, angle
        
        Notes
        -----
        Machine epsilon varies from machine to machine and between data types
        but Python floats on most platforms have a machine epsilon equal to
        2.2204460492503131e-16.  You can use 'np.finfo(np.float).eps' to print
        out the machine epsilon for floats.
        
        Examples
        --------
        >>> np.finfo(np.float).eps
        2.2204460492503131e-16
        
        >>> np.real_if_close([2.1 + 4e-14j], tol=1000)
        array([ 2.1])
        >>> np.real_if_close([2.1 + 4e-13j], tol=1000)
        array([ 2.1 +4.00000000e-13j])
    
    remez(numtaps, bands, desired, weight=None, Hz=1, type='bandpass', maxiter=25, grid_density=16)
        Calculate the minimax optimal filter using Remez exchange algorithm.
        
        Description:
        
          Calculate the filter-coefficients for the finite impulse response
          (FIR) filter whose transfer function minimizes the maximum error
          between the desired gain and the realized gain in the specified bands
          using the remez exchange algorithm.
        
        Inputs:
        
          numtaps -- The desired number of taps in the filter.
          bands -- A montonic sequence containing the band edges.  All elements
                   must be non-negative and less than 1/2 the sampling frequency
                   as given by Hz.
          desired -- A sequency half the size of bands containing the desired gain
                     in each of the specified bands
          weight -- A relative weighting to give to each band region.
          type --- The type of filter:
                   'bandpass' : flat response in bands.
                   'differentiator' : frequency proportional response in bands.
        
        Outputs: (out,)
        
          out -- A rank-1 array containing the coefficients of the optimal
                 (in a minimax sense) filter.
    
    resample(x, num, t=None, axis=0, window=None)
        Resample to num samples using Fourier method along the given axis.
        
        The resampled signal starts at the same value of x but is sampled
        with a spacing of len(x) / num * (spacing of x).  Because a
        Fourier method is used, the signal is assumed periodic.
        
        Window controls a Fourier-domain window that tapers the Fourier
        spectrum before zero-padding to alleviate ringing in the resampled
        values for sampled signals you didn't intend to be interpreted as
        band-limited.
        
        If window is a function, then it is called with a vector of inputs
        indicating the frequency bins (i.e. fftfreq(x.shape[axis]) )
        
        If window is an array of the same length as x.shape[axis] it is
        assumed to be the window to be applied directly in the Fourier
        domain (with dc and low-frequency first).
        
        If window is a string then use the named window.  If window is a
        float, then it represents a value of beta for a kaiser window.  If
        window is a tuple, then the first component is a string
        representing the window, and the next arguments are parameters for
        that window.  
        
        Possible windows are:
               'flattop'        -- 'flat', 'flt'
               'boxcar'         -- 'ones', 'box'
               'triang'         -- 'traing', 'tri'
               'parzen'         -- 'parz', 'par'
               'bohman'         -- 'bman', 'bmn'
               'blackmanharris' -- 'blackharr', 'bkh'
               'nuttall',       -- 'nutl', 'nut'
               'barthann'       -- 'brthan', 'bth'
               'blackman'       -- 'black',   'blk'
               'hamming'        -- 'hamm',    'ham'
               'bartlett'       -- 'bart',    'brt'
               'hanning'        -- 'hann',    'han'
               ('kaiser', beta)                 -- 'ksr'
               ('gaussian', std)                -- 'gauss',   'gss' 
               ('general gauss', power, width)  -- 'general', 'ggs'
               ('slepian', width)               -- 'slep', 'optimal', 'dss'
        
        The first sample of the returned vector is the same as the first
        sample of the input vector, the spacing between samples is changed
        from dx to
        
            dx * len(x) / num
        
        If t is not None, then it represents the old sample positions, and the new
        sample positions will be returned as well as the new samples.
    
    reshape(a, newshape, order='C')
        Gives a new shape to an array without changing its data.
        
        Parameters
        ----------
        a : array_like
            Array to be reshaped.
        newshape : int or tuple of ints
            The new shape should be compatible with the original shape. If
            an integer, then the result will be a 1-D array of that length.
            One shape dimension can be -1. In this case, the value is inferred
            from the length of the array and remaining dimensions.
        order : {'C', 'F'}, optional
            Determines whether the array data should be viewed as in C
            (row-major) order or FORTRAN (column-major) order.
        
        Returns
        -------
        reshaped_array : ndarray
            This will be a new view object if possible; otherwise, it will
            be a copy.
        
        
        See Also
        --------
        ndarray.reshape : Equivalent method.
        
        Notes
        -----
        
        It is not always possible to change the shape of an array without
        copying the data. If you want an error to be raise if the data is copied,
        you should assign the new shape to the shape attribute of the array::
        
         >>> a = np.zeros((10, 2))
         # A transpose make the array non-contiguous
         >>> b = a.T
         # Taking a view makes it possible to modify the shape without modiying the
         # initial object.
         >>> c = b.view()
         >>> c.shape = (20)
         AttributeError: incompatible shape for a non-contiguous array
        
        
        Examples
        --------
        >>> a = np.array([[1,2,3], [4,5,6]])
        >>> np.reshape(a, 6)
        array([1, 2, 3, 4, 5, 6])
        >>> np.reshape(a, 6, order='F')
        array([1, 4, 2, 5, 3, 6])
        
        >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
        array([[1, 2],
               [3, 4],
               [5, 6]])
    
    residue(b, a, tol=0.001, rtype='avg')
        Compute partial-fraction expansion of b(s) / a(s).
        
        If M = len(b) and N = len(a)
        
                b(s)     b[0] s**(M-1) + b[1] s**(M-2) + ... + b[M-1]
        H(s) = ------ = ----------------------------------------------
                a(s)     a[0] s**(N-1) + a[1] s**(N-2) + ... + a[N-1]
        
                 r[0]       r[1]             r[-1]
             = -------- + -------- + ... + --------- + k(s)
               (s-p[0])   (s-p[1])         (s-p[-1])
        
        If there are any repeated roots (closer than tol), then the partial
        fraction expansion has terms like
        
                r[i]      r[i+1]              r[i+n-1]
              -------- + ----------- + ... + -----------
              (s-p[i])  (s-p[i])**2          (s-p[i])**n
        
        Returns
        -------
        r : ndarray
            Residues
        p : ndarray
            Poles
        k : ndarray
            Coefficients of the direct polynomial term.
        
        See Also
        --------
        invres, poly, polyval, unique_roots
    
    residuez(b, a, tol=0.001, rtype='avg')
        Compute partial-fraction expansion of b(z) / a(z).
        
        If M = len(b) and N = len(a)
        
                b(z)     b[0] + b[1] z**(-1) + ... + b[M-1] z**(-M+1)
        H(z) = ------ = ----------------------------------------------
                a(z)     a[0] + a[1] z**(-1) + ... + a[N-1] z**(-N+1)
        
                     r[0]                   r[-1]
             = --------------- + ... + ---------------- + k[0] + k[1]z**(-1) ...
               (1-p[0]z**(-1))         (1-p[-1]z**(-1))
        
        If there are any repeated roots (closer than tol), then the partial
        fraction expansion has terms like
        
                   r[i]              r[i+1]                    r[i+n-1]
              -------------- + ------------------ + ... + ------------------
              (1-p[i]z**(-1))  (1-p[i]z**(-1))**2         (1-p[i]z**(-1))**n
        
        See also:  invresz, poly, polyval, unique_roots
    
    resize(a, new_shape)
        Return a new array with the specified shape.
        
        If the new array is larger than the original array, then the new
        array is filled with repeated copies of `a`.  Note that this behavior
        is different from a.resize(new_shape) which fills with zeros instead
        of repeated copies of `a`.
        
        Parameters
        ----------
        a : array_like
            Array to be resized.
        
        new_shape : int or tuple of int
            Shape of resized array.
        
        Returns
        -------
        reshaped_array : ndarray
            The new array is formed from the data in the old array, repeated
            if necessary to fill out the required number of elements.  The
            data are repeated in the order that they are stored in memory.
        
        See Also
        --------
        ndarray.resize : resize an array in-place.
        
        Examples
        --------
        >>> a=np.array([[0,1],[2,3]])
        >>> np.resize(a,(1,4))
        array([[0, 1, 2, 3]])
        >>> np.resize(a,(2,4))
        array([[0, 1, 2, 3],
               [0, 1, 2, 3]])
    
    roots(p)
        Return the roots of a polynomial with coefficients given in p.
        
        The values in the rank-1 array `p` are coefficients of a polynomial.
        If the length of `p` is n+1 then the polynomial is described by
        p[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]
        
        Parameters
        ----------
        p : array_like of shape(M,)
            Rank-1 array of polynomial co-efficients.
        
        Returns
        -------
        out : ndarray
            An array containing the complex roots of the polynomial.
        
        Raises
        ------
        ValueError:
            When `p` cannot be converted to a rank-1 array.
        
        See also
        --------
        
        poly : Find the coefficients of a polynomial with
             a given sequence of roots.
        polyval : Evaluate a polynomial at a point.
        polyfit : Least squares polynomial fit.
        poly1d : A one-dimensional polynomial class.
        
        Notes
        -----
        
        The algorithm relies on computing the eigenvalues of the
        companion matrix [1]_.
        
        References
        ----------
        .. [1] Wikipedia, "Companion matrix",
               http://en.wikipedia.org/wiki/Companion_matrix
        
        Examples
        --------
        
        >>> coeff = [3.2, 2, 1]
        >>> np.roots(coeff)
        array([-0.3125+0.46351241j, -0.3125-0.46351241j])
    
    sawtooth(t, width=1)
        Return a periodic sawtooth waveform.
        
        The sawtooth waveform has a period 2*pi, rises from -1 to 1 on the
        interval 0 to width*2*pi and drops from 1 to -1 on the interval
        width*2*pi to 2*pi. `width` must be in the interval [0,1].
        
        Parameters
        ----------
        t : array_like
            Time.
        width : float, optional
            Width of the waveform. Default is 1.
        
        Returns
        -------
        y : ndarray
            Output array containing the sawtooth waveform.
        
        Examples
        --------
        >>> import matplotlib.pyplot as plt
        >>> x = np.linspace(0, 20*np.pi, 500)
        >>> plt.plot(x, sp.signal.sawtooth(x))
    
    sepfir2d(...)
        sepfir2d(input, hrow, hcol) -> output
        
        Description:
        
          Convolve the rank-2 input array with the separable filter defined by the
          rank-1 arrays hrow, and hcol. Mirror symmetric boundary conditions are
          assumed.  This function can be used to find an image given its B-spline
          representation.
    
    size(a, axis=None)
        Return the number of elements along a given axis.
        
        Parameters
        ----------
        a : array_like
            Input data.
        axis : int, optional
            Axis along which the elements are counted.  By default, give
            the total number of elements.
        
        Returns
        -------
        element_count : int
            Number of elements along the specified axis.
        
        See Also
        --------
        shape : dimensions of array
        ndarray.shape : dimensions of array
        ndarray.size : number of elements in array
        
        Examples
        --------
        >>> a = np.array([[1,2,3],[4,5,6]])
        >>> np.size(a)
        6
        >>> np.size(a,1)
        3
        >>> np.size(a,0)
        2
    
    slepian(M, width, sym=True)
        Return the M-point slepian window.
    
    sort(a, axis=-1, kind='quicksort', order=None)
        Return a sorted copy of an array.
        
        Parameters
        ----------
        a : array_like
            Array to be sorted.
        axis : int or None, optional
            Axis along which to sort. If None, the array is flattened before
            sorting. The default is -1, which sorts along the last axis.
        kind : {'quicksort', 'mergesort', 'heapsort'}, optional
            Sorting algorithm. Default is 'quicksort'.
        order : list, optional
            When `a` is a structured array, this argument specifies which fields
            to compare first, second, and so on.  This list does not need to
            include all of the fields.
        
        Returns
        -------
        sorted_array : ndarray
            Array of the same type and shape as `a`.
        
        See Also
        --------
        ndarray.sort : Method to sort an array in-place.
        argsort : Indirect sort.
        lexsort : Indirect stable sort on multiple keys.
        searchsorted : Find elements in a sorted array.
        
        Notes
        -----
        The various sorting algorithms are characterized by their average speed,
        worst case performance, work space size, and whether they are stable. A
        stable sort keeps items with the same key in the same relative
        order. The three available algorithms have the following
        properties:
        
        =========== ======= ============= ============ =======
           kind      speed   worst case    work space  stable
        =========== ======= ============= ============ =======
        'quicksort'    1     O(n^2)            0          no
        'mergesort'    2     O(n*log(n))      ~n/2        yes
        'heapsort'     3     O(n*log(n))       0          no
        =========== ======= ============= ============ =======
        
        All the sort algorithms make temporary copies of the data when
        sorting along any but the last axis.  Consequently, sorting along
        the last axis is faster and uses less space than sorting along
        any other axis.
        
        The sort order for complex numbers is lexicographic. If both the real
        and imaginary parts are non-nan then the order is determined by the
        real parts except when they are equal, in which case the order is
        determined by the imaginary parts.
        
        Previous to numpy 1.4.0 sorting real and complex arrays containing nan
        values led to undefined behaviour. In numpy versions >= 1.4.0 nan
        values are sorted to the end. The extended sort order is:
        
          * Real: [R, nan]
          * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
        
        where R is a non-nan real value. Complex values with the same nan
        placements are sorted according to the non-nan part if it exists.
        Non-nan values are sorted as before.
        
        Examples
        --------
        >>> a = np.array([[1,4],[3,1]])
        >>> np.sort(a)                # sort along the last axis
        array([[1, 4],
               [1, 3]])
        >>> np.sort(a, axis=None)     # sort the flattened array
        array([1, 1, 3, 4])
        >>> np.sort(a, axis=0)        # sort along the first axis
        array([[1, 1],
               [3, 4]])
        
        Use the `order` keyword to specify a field to use when sorting a
        structured array:
        
        >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]
        >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
        ...           ('Galahad', 1.7, 38)]
        >>> a = np.array(values, dtype=dtype)       # create a structured array
        >>> np.sort(a, order='height')                        # doctest: +SKIP
        array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
               ('Lancelot', 1.8999999999999999, 38)],
              dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
        
        Sort by age, then height if ages are equal:
        
        >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP
        array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
               ('Arthur', 1.8, 41)],
              dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
    
    spline_filter(Iin, lmbda=5.0)
        Smoothing spline (cubic) filtering of a rank-2 array.
        
        Filter an input data set, Iin, using a (cubic) smoothing spline of
        fall-off lmbda.
    
    square(t, duty=0.5)
        Return a periodic square-wave waveform.
        
        The square wave has a period 2*pi, has value +1 from 0 to 2*pi*duty
        and -1 from 2*pi*duty to 2*pi. `duty` must be in the interval [0,1].
        
        Parameters
        ----------
        t : array_like
            The input time array.
        duty : float, optional
            Duty cycle.
        
        Returns
        -------
        y : array_like
            The output square wave.
    
    squeeze(a)
        Remove single-dimensional entries from the shape of an array.
        
        Parameters
        ----------
        a : array_like
            Input data.
        
        Returns
        -------
        squeezed : ndarray
            The input array, but with with all dimensions of length 1
            removed.  Whenever possible, a view on `a` is returned.
        
        Examples
        --------
        >>> x = np.array([[[0], [1], [2]]])
        >>> x.shape
        (1, 3, 1)
        >>> np.squeeze(x).shape
        (3,)
    
    ss2tf(A, B, C, D, input=0)
        State-space to transfer function.
        
        Parameters
        ----------
        A, B, C, D : ndarray
            State-space representation of linear system.
        input : int
            For multiple-input systems, the input to use.
        
        Returns
        -------
        num, den : 1D ndarray
            Numerator and denominator polynomials (as sequences)
            respectively.
    
    ss2zpk(A, B, C, D, input=0)
        State-space representation to zero-pole-gain representation.
        
        Inputs:
        
          A, B, C, D -- state-space matrices.
          input -- for multiple-input systems, the input to use.
        
        Outputs:
        
          z, p, k -- zeros and poles in sequences and gain constant.
    
    step(system, X0=None, T=None, N=None)
        Step response of continuous-time system.
        
        Parameters
        ----------
        system : an instance of the LTI class or a tuple describing the system.
            The following gives the number of elements in the tuple and
            the interpretation.
                2 (num, den)
                3 (zeros, poles, gain)
                4 (A, B, C, D)
        X0 : array_like, optional
            Initial state-vector (default is zero).
        T : array_like, optional
            Time points (computed if not given).
        N : int
            Number of time points to compute if `T` is not given.
        
        Returns
        -------
        T : 1D ndarray
            Output time points.
        yout : 1D ndarray
            Step response of system.
        
        See also
        --------
        scipy.signal.step2
    
    step2(system, X0=None, T=None, N=None, **kwargs)
        Step response of continuous-time system.
        
        This function is functionally the same as `scipy.signal.step`, but
        it uses the function `scipy.signal.lsim2` to compute the step
        response.
        
        Parameters
        ----------
        system : an instance of the LTI class or a tuple describing the system.
            The following gives the number of elements in the tuple and
            the interpretation.
                2 (num, den)
                3 (zeros, poles, gain)
                4 (A, B, C, D)
        X0 : array_like, optional
            Initial state-vector (default is zero).
        T : array_like, optional
            Time points (computed if not given).
        N : int
            Number of time points to compute if `T` is not given.
        **kwargs :
            Additional keyword arguments are passed on the function
            `scipy.signal.lsim2`, which in turn passes them on to
            :func:`scipy.integrate.odeint`.  See the documentation for
            :func:`scipy.integrate.odeint` for information about these
            arguments.
        
        Returns
        -------
        T : 1D ndarray
            Output time points.
        yout : 1D ndarray
            Step response of system.
        
        See also
        --------
        scipy.signal.step
        
        Notes
        -----
        .. versionadded:: 0.8.0
    
    sum(a, axis=None, dtype=None, out=None)
        Sum of array elements over a given axis.
        
        Parameters
        ----------
        a : array_like
            Elements to sum.
        axis : integer, optional
            Axis over which the sum is taken. By default `axis` is None,
            and all elements are summed.
        dtype : dtype, optional
            The type of the returned array and of the accumulator in which
            the elements are summed.  By default, the dtype of `a` is used.
            An exception is when `a` has an integer type with less precision
            than the default platform integer.  In that case, the default
            platform integer is used instead.
        out : ndarray, optional
            Array into which the output is placed.  By default, a new array is
            created.  If `out` is given, it must be of the appropriate shape
            (the shape of `a` with `axis` removed, i.e.,
            ``numpy.delete(a.shape, axis)``).  Its type is preserved. See
            `doc.ufuncs` (Section "Output arguments") for more details.
        
        Returns
        -------
        sum_along_axis : ndarray
            An array with the same shape as `a`, with the specified
            axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
            is returned.  If an output array is specified, a reference to
            `out` is returned.
        
        See Also
        --------
        ndarray.sum : Equivalent method.
        
        cumsum : Cumulative sum of array elements.
        
        trapz : Integration of array values using the composite trapezoidal rule.
        
        mean, average
        
        Notes
        -----
        Arithmetic is modular when using integer types, and no error is
        raised on overflow.
        
        Examples
        --------
        >>> np.sum([0.5, 1.5])
        2.0
        >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
        1
        >>> np.sum([[0, 1], [0, 5]])
        6
        >>> np.sum([[0, 1], [0, 5]], axis=0)
        array([0, 6])
        >>> np.sum([[0, 1], [0, 5]], axis=1)
        array([1, 5])
        
        If the accumulator is too small, overflow occurs:
        
        >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
        -128
    
    sweep_poly(t, poly, phi=0)
        Frequency-swept cosine generator, with a time-dependent frequency
        specified as a polynomial.
        
        This function generates a sinusoidal function whose instantaneous
        frequency varies with time.  The frequency at time `t` is given by
        the polynomial `poly`.
        
        Parameters
        ----------
        t : ndarray
            Times at which to evaluate the waveform.
        poly : 1D ndarray (or array-like), or instance of numpy.poly1d
            The desired frequency expressed as a polynomial.  If `poly` is
            a list or ndarray of length n, then the elements of `poly` are
            the coefficients of the polynomial, and the instantaneous
            frequency is
        
              ``f(t) = poly[0]*t**(n-1) + poly[1]*t**(n-2) + ... + poly[n-1]``
        
            If `poly` is an instance of numpy.poly1d, then the
            instantaneous frequency is
        
              ``f(t) = poly(t)``
        
        phi : float, optional
            Phase offset, in degrees. Default is 0.
        
        Returns
        -------
        A numpy array containing the signal evaluated at 't' with the requested
        time-varying frequency.  More precisely, the function returns
        
            ``cos(phase + (pi/180)*phi)``
        
        where `phase` is the integral (from 0 to t) of ``2 * pi * f(t)``;
        ``f(t)`` is defined above.
        
        See Also
        --------
        scipy.signal.waveforms.chirp
        
        Notes
        -----
        .. versionadded:: 0.8.0
    
    symiirorder1(...)
        symiirorder1(input, c0, z1 {, precision}) -> output
        
        Description:
        
          Implement a smoothing IIR filter with mirror-symmetric boundary conditions
          using a cascade of first-order sections.  The second section uses a
          reversed sequence.  This implements a system with the following
          transfer function and mirror-symmetric boundary conditions.
        
                                 c0              
                 H(z) = ---------------------    
                         (1-z1/z) (1 - z1 z)     
        
          The resulting signal will have mirror symmetric boundary conditions as well.
        
        Inputs:
        
          input -- the input signal.
          c0, z1 -- parameters in the transfer function.
          precision -- specifies the precision for calculating initial conditions
                       of the recursive filter based on mirror-symmetric input.
        
        Output:
        
          output -- filtered signal.
    
    symiirorder2(...)
        symiirorder2(input, r, omega {, precision}) -> output
        
        Description:
        
          Implement a smoothing IIR filter with mirror-symmetric boundary conditions
          using a cascade of second-order sections.  The second section uses a
          reversed sequence.  This implements the following transfer function:
        
                                              cs^2
                     H(z) = ---------------------------------------
                            (1 - a2/z - a3/z^2) (1 - a2 z - a3 z^2 )
        
          where a2 = (2 r cos omega)
                a3 = - r^2
                cs = 1 - 2 r cos omega + r^2
        
        Inputs:
        
          input -- the input signal.
          r, omega -- parameters in the transfer function.
          precision -- specifies the precision for calculating initial conditions
                       of the recursive filter based on mirror-symmetric input.
        
        Output:
        
          output -- filtered signal.
    
    take(a, indices, axis=None, out=None, mode='raise')
        Take elements from an array along an axis.
        
        This function does the same thing as "fancy" indexing (indexing arrays
        using arrays); however, it can be easier to use if you need elements
        along a given axis.
        
        Parameters
        ----------
        a : array_like
            The source array.
        indices : array_like
            The indices of the values to extract.
        axis : int, optional
            The axis over which to select values. By default, the flattened
            input array is used.
        out : ndarray, optional
            If provided, the result will be placed in this array. It should
            be of the appropriate shape and dtype.
        mode : {'raise', 'wrap', 'clip'}, optional
            Specifies how out-of-bounds indices will behave.
        
            * 'raise' -- raise an error (default)
            * 'wrap' -- wrap around
            * 'clip' -- clip to the range
        
            'clip' mode means that all indices that are too large are replaced
            by the index that addresses the last element along that axis. Note
            that this disables indexing with negative numbers.
        
        Returns
        -------
        subarray : ndarray
            The returned array has the same type as `a`.
        
        See Also
        --------
        ndarray.take : equivalent method
        
        Examples
        --------
        >>> a = [4, 3, 5, 7, 6, 8]
        >>> indices = [0, 1, 4]
        >>> np.take(a, indices)
        array([4, 3, 6])
        
        In this example if `a` is an ndarray, "fancy" indexing can be used.
        
        >>> a = np.array(a)
        >>> a[indices]
        array([4, 3, 6])
    
    tf2ss(num, den)
        Transfer function to state-space representation.
        
        Parameters
        ----------
        num, den : array_like
            Sequences representing the numerator and denominator
            polynomials.
        
        Returns
        -------
        A, B, C, D : ndarray
            State space representation of the system.
    
    tf2zpk(b, a)
        Return zero, pole, gain (z,p,k) representation from a numerator,
        denominator representation of a linear filter.
        
        Parameters
        ----------
        b : ndarray
            numerator polynomial.
        a : ndarray
            numerator and denominator polynomials.
        
        Returns
        -------
        z : ndarray
            zeros of the transfer function.
        p : ndarray
            poles of the transfer function.
        k : float
            system gain.
        
        If some values of b are too close to 0, they are removed. In that case, a
        BadCoefficients warning is emitted.
    
    transpose(a, axes=None)
        Permute the dimensions of an array.
        
        Parameters
        ----------
        a : array_like
            Input array.
        axes : list of ints, optional
            By default, reverse the dimensions, otherwise permute the axes
            according to the values given.
        
        Returns
        -------
        p : ndarray
            `a` with its axes permuted.  A view is returned whenever
            possible.
        
        See Also
        --------
        rollaxis
        
        Examples
        --------
        >>> x = np.arange(4).reshape((2,2))
        >>> x
        array([[0, 1],
               [2, 3]])
        
        >>> np.transpose(x)
        array([[0, 2],
               [1, 3]])
        
        >>> x = np.ones((1, 2, 3))
        >>> np.transpose(x, (1, 0, 2)).shape
        (2, 1, 3)
    
    triang(M, sym=True)
        The M-point triangular window.
    
    unique(ar, return_index=False, return_inverse=False)
        Find the unique elements of an array.
        
        Returns the sorted unique elements of an array. There are two optional
        outputs in addition to the unique elements: the indices of the input array
        that give the unique values, and the indices of the unique array that
        reconstruct the input array.
        
        Parameters
        ----------
        ar : array_like
            Input array. This will be flattened if it is not already 1-D.
        return_index : bool, optional
            If True, also return the indices of `ar` that result in the unique
            array.
        return_inverse : bool, optional
            If True, also return the indices of the unique array that can be used
            to reconstruct `ar`.
        
        Returns
        -------
        unique : ndarray
            The sorted unique values.
        unique_indices : ndarray, optional
            The indices of the unique values in the (flattened) original array.
            Only provided if `return_index` is True.
        unique_inverse : ndarray, optional
            The indices to reconstruct the (flattened) original array from the
            unique array. Only provided if `return_inverse` is True.
        
        See Also
        --------
        numpy.lib.arraysetops : Module with a number of other functions for
                                performing set operations on arrays.
        
        Examples
        --------
        >>> np.unique([1, 1, 2, 2, 3, 3])
        array([1, 2, 3])
        >>> a = np.array([[1, 1], [2, 3]])
        >>> np.unique(a)
        array([1, 2, 3])
        
        Return the indices of the original array that give the unique values:
        
        >>> a = np.array(['a', 'b', 'b', 'c', 'a'])
        >>> u, indices = np.unique(a, return_index=True)
        >>> u
        array(['a', 'b', 'c'],
               dtype='|S1')
        >>> indices
        array([0, 1, 3])
        >>> a[indices]
        array(['a', 'b', 'c'],
               dtype='|S1')
        
        Reconstruct the input array from the unique values:
        
        >>> a = np.array([1, 2, 6, 4, 2, 3, 2])
        >>> u, indices = np.unique(a, return_inverse=True)
        >>> u
        array([1, 2, 3, 4, 6])
        >>> indices
        array([0, 1, 4, 3, 1, 2, 1])
        >>> u[indices]
        array([1, 2, 6, 4, 2, 3, 2])
    
    unique_roots(p, tol=0.001, rtype='min')
        Determine the unique roots and their multiplicities in two lists
        
        Inputs:
        
          p -- The list of roots
          tol --- The tolerance for two roots to be considered equal.
          rtype --- How to determine the returned root from the close
                      ones:  'max': pick the maximum
                             'min': pick the minimum
                             'avg': average roots
        Outputs: (pout, mult)
        
          pout -- The list of sorted roots
          mult -- The multiplicity of each root
    
    vratio(u, ineps, mp)
    
    where(...)
        where(condition, [x, y])
        
        Return elements, either from `x` or `y`, depending on `condition`.
        
        If only `condition` is given, return ``condition.nonzero()``.
        
        Parameters
        ----------
        condition : array_like, bool
            When True, yield `x`, otherwise yield `y`.
        x, y : array_like, optional
            Values from which to choose. `x` and `y` need to have the same
            shape as `condition`.
        
        Returns
        -------
        out : ndarray or tuple of ndarrays
            If both `x` and `y` are specified, the output array contains
            elements of `x` where `condition` is True, and elements from
            `y` elsewhere.
        
            If only `condition` is given, return the tuple
            ``condition.nonzero()``, the indices where `condition` is True.
        
        See Also
        --------
        nonzero, choose
        
        Notes
        -----
        If `x` and `y` are given and input arrays are 1-D, `where` is
        equivalent to::
        
            [xv if c else yv for (c,xv,yv) in zip(condition,x,y)]
        
        Examples
        --------
        >>> np.where([[True, False], [True, True]],
        ...          [[1, 2], [3, 4]],
        ...          [[9, 8], [7, 6]])
        array([[1, 8],
               [3, 4]])
        
        >>> np.where([[0, 1], [1, 0]])
        (array([0, 1]), array([1, 0]))
        
        >>> x = np.arange(9.).reshape(3, 3)
        >>> np.where( x > 5 )
        (array([2, 2, 2]), array([0, 1, 2]))
        >>> x[np.where( x > 3.0 )]               # Note: result is 1D.
        array([ 4.,  5.,  6.,  7.,  8.])
        >>> np.where(x < 5, x, -1)               # Note: broadcasting.
        array([[ 0.,  1.,  2.],
               [ 3.,  4., -1.],
               [-1., -1., -1.]])
    
    wiener(im, mysize=None, noise=None)
        Perform a Wiener filter on an N-dimensional array.
        
        Description:
        
          Apply a Wiener filter to the N-dimensional array in.
        
        Inputs:
        
          in -- an N-dimensional array.
          kernel_size -- A scalar or an N-length list giving the size of the
                         Wiener filter window in each dimension.  Elements of
                         kernel_size should be odd.  If kernel_size is a scalar,
                         then this scalar is used as the size in each dimension.
          noise -- The noise-power to use.  If None, then noise is estimated as
                   the average of the local variance of the input.
        
        Outputs: (out,)
        
          out -- Wiener filtered result with the same shape as in.
    
    yulewalk()
    
    zeros(...)
        zeros(shape, dtype=float, order='C')
        
        Return a new array of given shape and type, filled with zeros.
        
        Parameters
        ----------
        shape : int or sequence of ints
            Shape of the new array, e.g., ``(2, 3)`` or ``2``.
        dtype : data-type, optional
            The desired data-type for the array, e.g., `numpy.int8`.  Default is
            `numpy.float64`.
        order : {'C', 'F'}, optional
            Whether to store multidimensional data in C- or Fortran-contiguous
            (row- or column-wise) order in memory.
        
        Returns
        -------
        out : ndarray
            Array of zeros with the given shape, dtype, and order.
        
        See Also
        --------
        zeros_like : Return an array of zeros with shape and type of input.
        ones_like : Return an array of ones with shape and type of input.
        empty_like : Return an empty array with shape and type of input.
        ones : Return a new array setting values to one.
        empty : Return a new uninitialized array.
        
        Examples
        --------
        >>> np.zeros(5)
        array([ 0.,  0.,  0.,  0.,  0.])
        
        >>> np.zeros((5,), dtype=numpy.int)
        array([0, 0, 0, 0, 0])
        
        >>> np.zeros((2, 1))
        array([[ 0.],
               [ 0.]])
        
        >>> s = (2,2)
        >>> np.zeros(s)
        array([[ 0.,  0.],
               [ 0.,  0.]])
        
        >>> np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype
        array([(0, 0), (0, 0)],
              dtype=[('x', '<i4'), ('y', '<i4')])
    
    zeros_like(a)
        Return an array of zeros with the same shape and type as a given array.
        
        Equivalent to ``a.copy().fill(0)``.
        
        Parameters
        ----------
        a : array_like
            The shape and data-type of `a` define these same attributes of
            the returned array.
        
        Returns
        -------
        out : ndarray
            Array of zeros with the same shape and type as `a`.
        
        See Also
        --------
        ones_like : Return an array of ones with shape and type of input.
        empty_like : Return an empty array with shape and type of input.
        zeros : Return a new array setting values to zero.
        ones : Return a new array setting values to one.
        empty : Return a new uninitialized array.
        
        Examples
        --------
        >>> x = np.arange(6)
        >>> x = x.reshape((2, 3))
        >>> x
        array([[0, 1, 2],
               [3, 4, 5]])
        >>> np.zeros_like(x)
        array([[0, 0, 0],
               [0, 0, 0]])
        
        >>> y = np.arange(3, dtype=np.float)
        >>> y
        array([ 0.,  1.,  2.])
        >>> np.zeros_like(y)
        array([ 0.,  0.,  0.])
    
    zpk2ss(z, p, k)
        Zero-pole-gain representation to state-space representation
        
        Parameters
        ----------
        z, p : sequence
            Zeros and poles.
        k : float
            System gain.
        
        Returns
        -------
        A, B, C, D : ndarray
            State-space matrices.
    
    zpk2tf(z, p, k)
        Return polynomial transfer function representation from zeros
        and poles
        
        Parameters
        ----------
        z : ndarray
            zeros of the transfer function.
        p : ndarray
            poles of the transfer function.
        k : float
            system gain.
        
        Returns
        -------
        b : ndarray
            numerator polynomial.
        a : ndarray
            numerator and denominator polynomials.
        
        Note
        ----
        If some values of b are too close to 0, they are removed. In that case, a
        BadCoefficients warning is emitted.

DATA
    EPSILON = 2e-16
    __all__ = ['BadCoefficients', 'EPSILON', 'abcd_normalize', 'abs', 'abs...
    abs = <ufunc 'absolute'>
    absolute = <ufunc 'absolute'>
    add = <ufunc 'add'>
    arccosh = <ufunc 'arccosh'>
    arcsinh = <ufunc 'arcsinh'>
    arctan = <ufunc 'arctan'>
    arctan2 = <ufunc 'arctan2'>
    band_dict = {'band': 'bandpass', 'bandpass': 'bandpass', 'bands': 'ban...
    cast = {<type 'numpy.int64'>: <function <lambda> at 0x0...umpy.uint16'...
    ceil = <ufunc 'ceil'>
    conjugate = <ufunc 'conjugate'>
    cos = <ufunc 'cos'>
    cosh = <ufunc 'cosh'>
    exp = <ufunc 'exp'>
    filter_dict = {'bessel': [<function besselap at 0x01308370>], 'butter'...
    floor = <ufunc 'floor'>
    gamma = <ufunc 'gamma'>
    greater = <ufunc 'greater'>
    greater_equal = <ufunc 'greater_equal'>
    less = <ufunc 'less'>
    less_equal = <ufunc 'less_equal'>
    log = <ufunc 'log'>
    log10 = <ufunc 'log10'>
    logical_and = <ufunc 'logical_and'>
    mod = <ufunc 'remainder'>
    nan = nan
    newaxis = None
    pi = 3.1415926535897931
    r_ = <numpy.lib.index_tricks.RClass object at 0x00CA5BF0>
    sin = <ufunc 'sin'>
    sinh = <ufunc 'sinh'>
    sqrt = <ufunc 'sqrt'>
    tan = <ufunc 'tan'>


None

