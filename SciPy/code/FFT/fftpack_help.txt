Help on package scipy.fftpack in scipy:

NAME
    scipy.fftpack

FILE
    c:\python26\lib\site-packages\scipy\fftpack\__init__.py

DESCRIPTION
    Discrete Fourier Transform algorithms
    =====================================
    
    Fast Fourier Transforms:
    
      fft       --- FFT of arbitrary type periodic sequences
      ifft      --- Inverse of fft
      fftn      --- Multi-dimensional FFT
      ifftn     --- Inverse of fftn
      fft2      --- Two-dimensional FFT
      ifft2     --- Inverse of fft2
      rfft      --- FFT of real periodic sequences
      irfft     --- Inverse of rfft
    
    Differential and pseudo-differential operators:
    
      diff      --- Differentiation and integration of periodic sequences
      tilbert   --- Tilbert transform:         cs_diff(x,h,h)
      itilbert  --- Inverse Tilbert transform: sc_diff(x,h,h)
      hilbert   --- Hilbert transform:         cs_diff(x,inf,inf)
      ihilbert  --- Inverse Hilbert transform: sc_diff(x,inf,inf)
      cs_diff   --- cosh/sinh pseudo-derivative of periodic sequences
      sc_diff   --- sinh/cosh pseudo-derivative of periodic sequences
      ss_diff   --- sinh/sinh pseudo-derivative of periodic sequences
      cc_diff   --- cosh/cosh pseudo-derivative of periodic sequences
      shift     --- Shift periodic sequences
    
    Helper functions:
    
      fftshift  --- Shift zero-frequency component to center of spectrum
      ifftshift --- Inverse of freqshift
      dftfreq   --- DFT sample frequencies
      rfftfreq  --- DFT sample frequencies (specific to rfft,irfft)
    
    Extension modules:
    
      _fftpack   --- Provides functions zfft, drfft, zrfft, zfftnd,
                    destroy_*_cache
      convolve  --- Provides functions convolve, convolve_z,
                    init_convolution_kernel, destroy_convolve_cache

PACKAGE CONTENTS
    _fftpack
    basic
    convolve
    fftpack_version
    helper
    info
    pseudo_diffs
    realtransforms
    setup
    setupscons

FUNCTIONS
    cc_diff(x, a, b, period=None, _cache={})
        cc_diff(x, a, b, period=2*pi) -> y
        
        Return (a,b)-cosh/cosh pseudo-derivative of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = cosh(j*a*2*pi/period)/cosh(j*b*2*pi/period) * x_j
        
        Input:
          a,b
            Defines the parameters of the sinh/sinh pseudo-differential
            operator.
        
        Optional input:
          period
            The period of the sequence x. Default is 2*pi.
        
        Notes:
          cc_diff(cc_diff(x,a,b),b,a) == x
    
    cs_diff(x, a, b, period=None, _cache={})
        cs_diff(x, a, b, period=2*pi) -> y
        
        Return (a,b)-cosh/sinh pseudo-derivative of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = -sqrt(-1)*cosh(j*a*2*pi/period)/sinh(j*b*2*pi/period) * x_j
          y_0 = 0
        
        Input:
          a,b
            Defines the parameters of the cosh/sinh pseudo-differential
            operator.
          period
            The period of the sequence. Default period is 2*pi.
        
        Notes:
          For even len(x), the Nyquist mode of x is taken zero.
    
    dct(x, type=2, n=None, axis=-1, norm=None)
        Return the Discrete Cosine Transform of arbitrary type sequence x.
        
        Parameters
        ----------
        x : array-like
            The input array.
        type : {1, 2, 3}, optional
            Type of the DCT (see Notes). Default type is 2.
        n : int, optional
            Length of the transform.
        axis : int, optional
            Axis over which to compute the transform.
        norm : {None, 'ortho'}, optional
            Normalization mode (see Notes). Default is None.
        
        Returns
        -------
        y : ndarray of real
            The transformed input array.
        
        See Also
        --------
        idct
        
        Notes
        -----
        For a single dimension array ``x``, ``dct(x, norm='ortho')`` is equal to
        matlab ``dct(x)``.
        
        There are theoretically 8 types of the DCT, only the first 3 types are
        implemented in scipy. 'The' DCT generally refers to DCT type 2, and 'the'
        Inverse DCT generally refers to DCT type 3.
        
        type I
        ~~~~~~
        There are several definitions of the DCT-I; we use the following
        (for ``norm=None``)::
        
                                             N-2
          y[k] = x[0] + (-1)**k x[N-1] + 2 * sum x[n]*cos(pi*k*n/(N-1))
                                             n=1
        
        Only None is supported as normalization mode for DCT-I. Note also that the
        DCT-I is only supported for input size > 1
        
        type II
        ~~~~~~~
        There are several definitions of the DCT-II; we use the following
        (for ``norm=None``)::
        
        
                    N-1
          y[k] = 2* sum x[n]*cos(pi*k*(2n+1)/(2*N)), 0 <= k < N.
                    n=0
        
        If ``norm='ortho'``, ``y[k]`` is multiplied by a scaling factor `f`::
        
          f = sqrt(1/(4*N)) if k = 0,
          f = sqrt(1/(2*N)) otherwise.
        
        Which makes the corresponding matrix of coefficients orthonormal
        (``OO' = Id``).
        
        type III
        ~~~~~~~~
        
        There are several definitions, we use the following
        (for ``norm=None``)::
        
                            N-1
          y[k] = x[0] + 2 * sum x[n]*cos(pi*(k+0.5)*n/N), 0 <= k < N.
                            n=1
        
        or, for ``norm='ortho'`` and 0 <= k < N::
        
                                              N-1
          y[k] = x[0] / sqrt(N) + sqrt(1/N) * sum x[n]*cos(pi*(k+0.5)*n/N)
                                              n=1
        
        The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up
        to a factor `2N`. The orthonormalized DCT-III is exactly the inverse of
        the orthonormalized DCT-II.
        
        References
        ----------
        
        http://en.wikipedia.org/wiki/Discrete_cosine_transform
        
        'A Fast Cosine Transform in One and Two Dimensions', by J. Makhoul, `IEEE
        Transactions on acoustics, speech and signal processing` vol. 28(1),
        pp. 27-34, http://dx.doi.org/10.1109/TASSP.1980.1163351 (1980).
    
    diff(x, order=1, period=None, _cache={})
        diff(x, order=1, period=2*pi) -> y
        
        Return k-th derivative (or integral) of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = pow(sqrt(-1)*j*2*pi/period, order) * x_j
          y_0 = 0 if order is not 0.
        
        Optional input:
          order
            The order of differentiation. Default order is 1. If order is
            negative, then integration is carried out under the assumption
            that x_0==0.
          period
            The assumed period of the sequence. Default is 2*pi.
        
        Notes:
          If sum(x,axis=0)=0 then
              diff(diff(x,k),-k)==x (within numerical accuracy)
          For odd order and even len(x), the Nyquist mode is taken zero.
    
    fft(x, n=None, axis=-1, overwrite_x=0)
        Return discrete Fourier transform of arbitrary type sequence x.
        
        Parameters
        ----------
        x : array-like
            array to fourier transform.
        n : int, optional
            Length of the Fourier transform. If n<x.shape[axis],
            x is truncated. If n>x.shape[axis], x is zero-padded.
            (Default n=x.shape[axis]).
        axis : int, optional
            Axis along which the fft's are computed. (default=-1)
        overwrite_x : bool, optional
            If True the contents of x can be destroyed. (default=False)
        
        Returns
        -------
        z : complex ndarray
            with the elements:
                [y(0),y(1),..,y(n/2-1),y(-n/2),...,y(-1)]        if n is even
                [y(0),y(1),..,y((n-1)/2),y(-(n-1)/2),...,y(-1)]  if n is odd
            where
                y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k* 2*pi/n), j = 0..n-1
            Note that y(-j) = y(n-j).conjugate().
        
        See Also
        --------
        ifft : Inverse FFT
        rfft : FFT of a real sequence
        
        Notes
        -----
        The packing of the result is "standard": If A = fft(a, n), then A[0]
        contains the zero-frequency term, A[1:n/2+1] contains the
        positive-frequency terms, and A[n/2+1:] contains the negative-frequency
        terms, in order of decreasingly negative frequency. So for an 8-point
        transform, the frequencies of the result are [ 0, 1, 2, 3, 4, -3, -2, -1].
        
        This is most efficient for n a power of two.
        
        .. note:: In scipy 0.8.0 `fft` in single precision is available, but *only*
            for input array sizes which can be factorized into (combinations of) 2,
            3 and 5. For other sizes the computation will be done in double
            precision.
        
        Examples
        --------
        >>> x = np.arange(5)
        >>> np.all(np.abs(x-fft(ifft(x))<1.e-15) #within numerical accuracy.
        True
    
    fft2(x, shape=None, axes=(-2, -1), overwrite_x=0)
        2-D discrete Fourier transform.
        
        Return the two-dimensional discrete Fourier transform of the 2-D argument
        `x`.
        
        See Also
        --------
        fftn : for detailed information.
    
    fftn(x, shape=None, axes=None, overwrite_x=0)
        fftn(x, shape=None, axes=None, overwrite_x=0) -> y
        
        Return multi-dimensional discrete Fourier transform of arbitrary
        type sequence x.
        
        The returned array contains
        
          y[j_1,..,j_d] = sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
             x[k_1,..,k_d] * prod[i=1..d] exp(-sqrt(-1)*2*pi/n_i * j_i * k_i)
        
        where d = len(x.shape) and n = x.shape.
        Note that y[..., -j_i, ...] = y[..., n_i-j_i, ...].conjugate().
        
        Optional input:
          shape
            Defines the shape of the Fourier transform. If shape is not
            specified then shape=take(x.shape,axes,axis=0).
            If shape[i]>x.shape[i] then the i-th dimension is padded with
            zeros. If shape[i]<x.shape[i], then the i-th dimension is
            truncated to desired length shape[i].
          axes
            The transform is applied along the given axes of the input
            array (or the newly constructed array if shape argument was
            used).
          overwrite_x
            If set to true, the contents of x can be destroyed.
        
        Notes:
          y == fftn(ifftn(y)) within numerical accuracy.
    
    hilbert(x, _cache={})
        hilbert(x) -> y
        
        Return Hilbert transform of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = sqrt(-1)*sign(j) * x_j
          y_0 = 0
        
        Notes:
          If sum(x,axis=0)==0 then
            hilbert(ihilbert(x)) == x
          For even len(x), the Nyquist mode of x is taken zero.
    
    idct(x, type=2, n=None, axis=-1, norm=None)
        Return the Inverse Discrete Cosine Transform of arbitrary type sequence x.
        
        Parameters
        ----------
        x : array-like
            The input array.
        type : {1, 2, 3}, optional
            Type of the DCT (see Notes). Default type is 2.
        n : int, optional
            Length of the transform.
        axis : int, optional
            Axis over which to compute the transform.
        norm : {None, 'ortho'}, optional
            Normalization mode (see Notes). Default is None.
        
        Returns
        -------
        y : ndarray of real
            The transformed input array.
        
        See Also
        --------
        dct
        
        Notes
        -----
        For a single dimension array `x`, ``idct(x, norm='ortho')`` is equal to
        matlab ``idct(x)``.
        
        'The' IDCT is the IDCT of type 2, which is the same as DCT of type 3.
        
        IDCT of type 1 is the DCT of type 1, IDCT of type 2 is the DCT of type 3,
        and IDCT of type 3 is the DCT of type 2. For the definition of these types,
        see `dct`.
    
    ifft(x, n=None, axis=-1, overwrite_x=0)
        ifft(x, n=None, axis=-1, overwrite_x=0) -> y
        
        Return inverse discrete Fourier transform of arbitrary type
        sequence x.
        
        The returned complex array contains
          [y(0),y(1),...,y(n-1)]
        where
          y(j) = 1/n sum[k=0..n-1] x[k] * exp(sqrt(-1)*j*k* 2*pi/n)
        
        Optional input: see fft.__doc__
    
    ifft2(x, shape=None, axes=(-2, -1), overwrite_x=0)
        ifft2(x, shape=None, axes=(-2,-1), overwrite_x=0) -> y
        
        Return inverse two-dimensional discrete Fourier transform of
        arbitrary type sequence x.
        
        See ifftn.__doc__ for more information.
    
    ifftn(x, shape=None, axes=None, overwrite_x=0)
        Return inverse multi-dimensional discrete Fourier transform of
        arbitrary type sequence x.
        
        The returned array contains::
        
          y[j_1,..,j_d] = 1/p * sum[k_1=0..n_1-1, ..., k_d=0..n_d-1]
             x[k_1,..,k_d] * prod[i=1..d] exp(sqrt(-1)*2*pi/n_i * j_i * k_i)
        
        where ``d = len(x.shape)``, ``n = x.shape``, and ``p = prod[i=1..d] n_i``.
        
        For description of parameters see `fftn`.
        
        See Also
        --------
        fftn : for detailed information.
    
    ihilbert(x)
        ihilbert(x) -> y
        
        Return inverse Hilbert transform of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = -sqrt(-1)*sign(j) * x_j
          y_0 = 0
    
    irfft(x, n=None, axis=-1, overwrite_x=0)
        irfft(x, n=None, axis=-1, overwrite_x=0) -> y
        
        Return inverse discrete Fourier transform of real sequence x.
        The contents of x is interpreted as the output of rfft(..)
        function.
        
        The returned real array contains
          [y(0),y(1),...,y(n-1)]
        where for n is even
          y(j) = 1/n (sum[k=1..n/2-1] (x[2*k-1]+sqrt(-1)*x[2*k])
                                       * exp(sqrt(-1)*j*k* 2*pi/n)
                      + c.c. + x[0] + (-1)**(j) x[n-1])
        and for n is odd
          y(j) = 1/n (sum[k=1..(n-1)/2] (x[2*k-1]+sqrt(-1)*x[2*k])
                                       * exp(sqrt(-1)*j*k* 2*pi/n)
                      + c.c. + x[0])
        c.c. denotes complex conjugate of preceeding expression.
        
        Optional input: see rfft.__doc__
    
    itilbert(x, h, period=None, _cache={})
        itilbert(x, h, period=2*pi) -> y
        
        Return inverse h-Tilbert transform of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = -sqrt(-1)*tanh(j*h*2*pi/period) * x_j
          y_0 = 0
        
        Optional input: see tilbert.__doc__
    
    rfft(x, n=None, axis=-1, overwrite_x=0)
        rfft(x, n=None, axis=-1, overwrite_x=0) -> y
        
        Return discrete Fourier transform of real sequence x.
        
        The returned real arrays contains
          [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2))]              if n is even
          [y(0),Re(y(1)),Im(y(1)),...,Re(y(n/2)),Im(y(n/2))]   if n is odd
        where
          y(j) = sum[k=0..n-1] x[k] * exp(-sqrt(-1)*j*k* 2*pi/n)
          j = 0..n-1
        Note that y(-j) = y(n-j).conjugate().
        
        Optional input:
          n
            Defines the length of the Fourier transform. If n is not
            specified then n=x.shape[axis] is set. If n<x.shape[axis],
            x is truncated. If n>x.shape[axis], x is zero-padded.
          axis
            The transform is applied along the given axis of the input
            array (or the newly constructed array if n argument was used).
          overwrite_x
            If set to true, the contents of x can be destroyed.
        
        Notes:
          y == rfft(irfft(y)) within numerical accuracy.
    
    rfftfreq(n, d=1.0)
        rfftfreq(n, d=1.0) -> f
        
        DFT sample frequencies (for usage with rfft,irfft).
        
        The returned float array contains the frequency bins in
        cycles/unit (with zero at the start) given a window length n and a
        sample spacing d:
        
          f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2]/(d*n)   if n is even
          f = [0,1,1,2,2,...,n/2-1,n/2-1,n/2,n/2]/(d*n)   if n is odd
    
    sc_diff(x, a, b, period=None, _cache={})
        Return (a,b)-sinh/cosh pseudo-derivative of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then::
        
          y_j = sqrt(-1)*sinh(j*a*2*pi/period)/cosh(j*b*2*pi/period) * x_j
          y_0 = 0
        
        Parameters
        ----------
        x : array_like
            Input array.
        a,b : float
            Defines the parameters of the sinh/cosh pseudo-differential
            operator.
        period : float, optional
            The period of the sequence x. Default is 2*pi.
        
        Notes
        -----
        ``sc_diff(cs_diff(x,a,b),b,a) == x``
        For even ``len(x)``, the Nyquist mode of x is taken as zero.
    
    shift(x, a, period=None, _cache={})
        shift(x, a, period=2*pi) -> y
        
        Shift periodic sequence x by a: y(u) = x(u+a).
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
              y_j = exp(j*a*2*pi/period*sqrt(-1)) * x_f
        
        Optional input:
          period
            The period of the sequences x and y. Default period is 2*pi.
    
    ss_diff(x, a, b, period=None, _cache={})
        ss_diff(x, a, b, period=2*pi) -> y
        
        Return (a,b)-sinh/sinh pseudo-derivative of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = sinh(j*a*2*pi/period)/sinh(j*b*2*pi/period) * x_j
          y_0 = a/b * x_0
        
        Input:
          a,b
            Defines the parameters of the sinh/sinh pseudo-differential
            operator.
          period
            The period of the sequence x. Default is 2*pi.
        
        Notes:
          ss_diff(ss_diff(x,a,b),b,a) == x
    
    tilbert(x, h, period=None, _cache={})
        tilbert(x, h, period=2*pi) -> y
        
        Return h-Tilbert transform of a periodic sequence x.
        
        If x_j and y_j are Fourier coefficients of periodic functions x
        and y, respectively, then
        
          y_j = sqrt(-1)*coth(j*h*2*pi/period) * x_j
          y_0 = 0
        
        Input:
          h
            Defines the parameter of the Tilbert transform.
          period
            The assumed period of the sequence. Default period is 2*pi.
        
        Notes:
          If sum(x,axis=0)==0 and n=len(x) is odd then
            tilbert(itilbert(x)) == x
          If 2*pi*h/period is approximately 10 or larger then numerically
            tilbert == hilbert
          (theoretically oo-Tilbert == Hilbert).
          For even len(x), the Nyquist mode of x is taken zero.

DATA
    __all__ = ['fft', 'ifft', 'fftn', 'ifftn', 'rfft', 'irfft', 'fft2', 'i...
    __version__ = '0.4.3'

VERSION
    0.4.3


None

