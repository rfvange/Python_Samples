% g = [1,0,0,1,1,1,1;1,1,0,1,1,0,1] % generator polynomial for rate 1/2 m = 6
                                    % convolutional encode
% g = [1,1,1;1,1,1;1,0,1]           % generator polynomial for rate 1/3 m = 2
                                    % convolutional encoder
% g = [1,0,0,1,1,1,1;1,0,1,0,1,1,1;1,1,0,1,1,0,1] % generator polynomial for rate 1/3
                                                  %m = 6 convolutional encoder

%----------------------------------------------------------------------------------
% * Tested generator polynomials for which the FEC technique is implemented *
%----------------------------------------------------------------------------------

g = [1,0,1;1,1,1]         % generator polynomial for rate 1/2 m = 2 convolutional encoder
% g = [1,0,1,1,0,1,1;1,1,1,1,0,0,1]   % generator polynomial for rate 1/2 m = 6
                                      % convolutional encoder
% g = [ 1,0,1;0,1,0;1,1,0]            % generator polynomial for rate 1/3 m = 2
                                      % convolutional encoder
% g = [1,0,1,1,0,1,1:1,1,1,1,0,0,1;1,1,0,0,1,0,1] % generator polynomial for rate 1/3
                                                  %m = 6 convolutional encoder

%---------------------------
% * Convolutional Encoding *
%---------------------------
% - Start -

% refer to hard_decision_Viterbi.m and soft_decision_Viterbi.m

% - End -

antipodal_conv(find(antipodal_conv >= 1)) = 1 ;   % conversion of encoded bits to
                                                  % antipodal signal
antipodal_conv(find(antipodal_conv <= 0)) = -1;
antipodal_conv;

Ltx = length(antipodal_conv);

Eb_No;
Es_No = Eb_No + 10 * log10 (1 / 2);     % Es_No calculated depending on the
                                        % convolutional encoder used
No=1 ./ (10.^(Es_No ./ 10));

for i = 1:LE
    i;

%----------------------------
% * Generating AWGN channel *
%----------------------------